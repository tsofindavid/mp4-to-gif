{"ast":null,"code":"import _asyncToGenerator from \"/Users/David/Documents/own_projects/mp4-to-gif/packages/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nconst SEPARATOR = /\\W|_/g;\nfunction camelizeString(text) {\n  return text.split(SEPARATOR).map((word, index) => word.charAt(0)[index > 0 ? 'toUpperCase' : 'toLowerCase']() + word.slice(1)).join('');\n}\nfunction camelizeArrayItems(array, {\n  ignoreKeys\n} = {\n  ignoreKeys: []\n}) {\n  if (!Array.isArray(array)) {\n    return array;\n  }\n  return array.map(item => camelizeKeys(item, {\n    ignoreKeys\n  }));\n}\nfunction camelizeKeys(source, {\n  ignoreKeys\n} = {\n  ignoreKeys: []\n}) {\n  if (Array.isArray(source)) {\n    return camelizeArrayItems(source, {\n      ignoreKeys\n    });\n  }\n  if (!isObject(source)) {\n    return source;\n  }\n  const result = {};\n  for (const key of Object.keys(source)) {\n    let value = source[key];\n    if (ignoreKeys.includes(key)) {\n      result[key] = value;\n      continue;\n    }\n    if (isObject(value)) {\n      value = camelizeKeys(value, {\n        ignoreKeys\n      });\n    } else if (Array.isArray(value)) {\n      value = camelizeArrayItems(value, {\n        ignoreKeys\n      });\n    }\n    result[camelizeString(key)] = value;\n  }\n  return result;\n}\n\n/**\n * SetTimeout as Promise.\n *\n * @param {number} ms Timeout in milliseconds.\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nfunction getUserAgent$1({\n  libraryName,\n  libraryVersion,\n  userAgent,\n  publicKey = '',\n  integration = ''\n}) {\n  const languageName = 'JavaScript';\n  if (typeof userAgent === 'string') {\n    return userAgent;\n  }\n  if (typeof userAgent === 'function') {\n    return userAgent({\n      publicKey,\n      libraryName,\n      libraryVersion,\n      languageName,\n      integration\n    });\n  }\n  const mainInfo = [libraryName, libraryVersion, publicKey].filter(Boolean).join('/');\n  const additionInfo = [languageName, integration].filter(Boolean).join('; ');\n  return `${mainInfo} (${additionInfo})`;\n}\nconst defaultOptions = {\n  factor: 2,\n  time: 100\n};\nfunction retrier(fn, options = defaultOptions) {\n  let attempts = 0;\n  function runAttempt(fn) {\n    const defaultDelayTime = Math.round(options.time * options.factor ** attempts);\n    const retry = ms => delay(ms ?? defaultDelayTime).then(() => {\n      attempts += 1;\n      return runAttempt(fn);\n    });\n    return fn({\n      attempt: attempts,\n      retry\n    });\n  }\n  return runAttempt(fn);\n}\nclass UploadcareError extends Error {}\nclass NetworkError extends UploadcareError {\n  originalProgressEvent;\n  constructor(progressEvent) {\n    super();\n    this.name = 'NetworkError';\n    this.message = 'Network error';\n    Object.setPrototypeOf(this, NetworkError.prototype);\n    this.originalProgressEvent = progressEvent;\n  }\n}\nconst onCancel = (signal, callback) => {\n  if (signal) {\n    if (signal.aborted) {\n      Promise.resolve().then(callback);\n    } else {\n      signal.addEventListener('abort', () => callback(), {\n        once: true\n      });\n    }\n  }\n};\nclass CancelError extends UploadcareError {\n  isCancel = true;\n  constructor(message = 'Request canceled') {\n    super(message);\n    this.name = 'CancelError';\n    Object.setPrototypeOf(this, CancelError.prototype);\n  }\n}\nconst DEFAULT_INTERVAL = 500;\nconst poll = ({\n  check,\n  interval = DEFAULT_INTERVAL,\n  timeout,\n  signal\n}) => new Promise((resolve, reject) => {\n  let tickTimeoutId;\n  let timeoutId;\n  onCancel(signal, () => {\n    tickTimeoutId && clearTimeout(tickTimeoutId);\n    reject(new CancelError('Poll cancelled'));\n  });\n  if (timeout) {\n    timeoutId = setTimeout(() => {\n      tickTimeoutId && clearTimeout(tickTimeoutId);\n      reject(new CancelError('Timed out'));\n    }, timeout);\n  }\n  const tick = () => {\n    try {\n      Promise.resolve(check(signal)).then(result => {\n        if (result) {\n          timeoutId && clearTimeout(timeoutId);\n          resolve(result);\n        } else {\n          tickTimeoutId = setTimeout(tick, interval);\n        }\n      }).catch(error => {\n        timeoutId && clearTimeout(timeoutId);\n        reject(error);\n      });\n    } catch (error) {\n      timeoutId && clearTimeout(timeoutId);\n      reject(error);\n    }\n  };\n  tickTimeoutId = setTimeout(tick, 0);\n});\n\n/*\n  Settings for future support:\n  parallelDirectUploads: 10,\n */\nconst defaultSettings = {\n  baseCDN: 'https://ucarecdn.com',\n  baseURL: 'https://upload.uploadcare.com',\n  maxContentLength: 50 * 1024 * 1024,\n  // 50 MB\n  retryThrottledRequestMaxTimes: 1,\n  retryNetworkErrorMaxTimes: 3,\n  multipartMinFileSize: 25 * 1024 * 1024,\n  // 25 MB\n  multipartChunkSize: 5 * 1024 * 1024,\n  // 5 MB\n  multipartMinLastPartSize: 1024 * 1024,\n  // 1MB\n  maxConcurrentRequests: 4,\n  pollingTimeoutMilliseconds: 10000,\n  pusherKey: '79ae88bd931ea68464d9'\n};\nconst defaultContentType = 'application/octet-stream';\nconst defaultFilename = 'original';\nconst request = ({\n  method,\n  url,\n  data,\n  headers = {},\n  signal,\n  onProgress\n}) => new Promise((resolve, reject) => {\n  const xhr = new XMLHttpRequest();\n  const requestMethod = method?.toUpperCase() || 'GET';\n  let aborted = false;\n  /**\n   * Force synchronous flag to be off Some chrome versions gets\n   * `InvalidAccessError` error when we set `responseType` See\n   * https://xhr.spec.whatwg.org/#synchronous-flag and\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=1346628\n   */\n  xhr.open(requestMethod, url, true);\n  if (headers) {\n    Object.entries(headers).forEach(entry => {\n      const [key, value] = entry;\n      typeof value !== 'undefined' && !Array.isArray(value) && xhr.setRequestHeader(key, value);\n    });\n  }\n  xhr.responseType = 'text';\n  onCancel(signal, () => {\n    aborted = true;\n    xhr.abort();\n    reject(new CancelError());\n  });\n  xhr.onload = () => {\n    if (xhr.status != 200) {\n      // analyze HTTP status of the response\n      reject(new Error(`Error ${xhr.status}: ${xhr.statusText}`)); // e.g. 404: Not Found\n    } else {\n      const request = {\n        method: requestMethod,\n        url,\n        data,\n        headers: headers || undefined,\n        signal,\n        onProgress\n      };\n      // Convert the header string into an array\n      // of individual headers\n      const headersArray = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n      // Create a map of header names to values\n      const responseHeaders = {};\n      headersArray.forEach(function (line) {\n        const parts = line.split(': ');\n        const header = parts.shift();\n        const value = parts.join(': ');\n        if (header && typeof header !== 'undefined') {\n          responseHeaders[header] = value;\n        }\n      });\n      const responseData = xhr.response;\n      const responseStatus = xhr.status;\n      resolve({\n        request,\n        data: responseData,\n        headers: responseHeaders,\n        status: responseStatus\n      });\n    }\n  };\n  xhr.onerror = progressEvent => {\n    if (aborted) return;\n    // only triggers if the request couldn't be made at all\n    reject(new NetworkError(progressEvent));\n  };\n  if (onProgress && typeof onProgress === 'function') {\n    xhr.upload.onprogress = event => {\n      if (event.lengthComputable) {\n        onProgress({\n          isComputable: true,\n          value: event.loaded / event.total\n        });\n      } else {\n        onProgress({\n          isComputable: false\n        });\n      }\n    };\n  }\n  if (data) {\n    xhr.send(data);\n  } else {\n    xhr.send();\n  }\n});\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction identity(obj, ..._args) {\n  return obj;\n}\nconst getFileOptions = ({\n  name\n}) => name ? [name] : [];\nconst transformFile = identity;\nvar getFormData = () => new FormData();\nconst isBuffer = data => false;\nconst isBlob = data => {\n  return typeof Blob !== 'undefined' && data instanceof Blob;\n};\nconst isFile = data => {\n  return typeof File !== 'undefined' && data instanceof File;\n};\nconst isReactNativeAsset = data => {\n  return !!data && typeof data === 'object' && !Array.isArray(data) && 'uri' in data && typeof data.uri === 'string';\n};\nconst isFileData = data => {\n  return isBlob(data) || isFile(data) || isBuffer() || isReactNativeAsset(data);\n};\nconst isSimpleValue = value => {\n  return typeof value === 'string' || typeof value === 'number' || typeof value === 'undefined';\n};\nconst isObjectValue = value => {\n  return !!value && typeof value === 'object' && !Array.isArray(value);\n};\nconst isFileValue = value => !!value && typeof value === 'object' && 'data' in value && isFileData(value.data);\nfunction collectParams(params, inputKey, inputValue) {\n  if (Array.isArray(inputValue)) {\n    for (const value of inputValue) {\n      collectParams(params, `${inputKey}[]`, value);\n    }\n  } else if (isFileValue(inputValue)) {\n    const {\n      name,\n      contentType\n    } = inputValue;\n    const file = transformFile(inputValue.data, name, contentType ?? defaultContentType);\n    const options = getFileOptions({\n      name,\n      contentType\n    });\n    params.push([inputKey, file, ...options]);\n  } else if (isObjectValue(inputValue)) {\n    for (const [key, value] of Object.entries(inputValue)) {\n      if (typeof value !== 'undefined') {\n        params.push([`${inputKey}[${key}]`, String(value)]);\n      }\n    }\n  } else if (isSimpleValue(inputValue) && inputValue) {\n    params.push([inputKey, inputValue.toString()]);\n  }\n}\nfunction getFormDataParams(options) {\n  const params = [];\n  for (const [key, value] of Object.entries(options)) {\n    collectParams(params, key, value);\n  }\n  return params;\n}\nfunction buildFormData(options) {\n  const formData = getFormData();\n  const paramsList = getFormDataParams(options);\n  for (const params of paramsList) {\n    const [key, value, ...rest] = params;\n    // node form-data has another signature for append\n    formData.append(key, value, ...rest);\n  }\n  return formData;\n}\nclass UploadError extends UploadcareError {\n  code;\n  request;\n  response;\n  headers;\n  constructor(message, code, request, response, headers) {\n    super();\n    this.name = 'UploadError';\n    this.message = message;\n    this.code = code;\n    this.request = request;\n    this.response = response;\n    this.headers = headers;\n    Object.setPrototypeOf(this, UploadError.prototype);\n  }\n}\nconst buildSearchParams = query => {\n  const searchParams = new URLSearchParams();\n  for (const [key, value] of Object.entries(query)) {\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      Object.entries(value).filter(entry => entry[1] ?? false).forEach(entry => searchParams.set(`${key}[${entry[0]}]`, String(entry[1])));\n    } else if (Array.isArray(value)) {\n      value.forEach(val => {\n        searchParams.append(`${key}[]`, val);\n      });\n    } else if (typeof value === 'string' && value) {\n      searchParams.set(key, value);\n    } else if (typeof value === 'number') {\n      searchParams.set(key, value.toString());\n    }\n  }\n  return searchParams.toString();\n};\nconst getUrl = (base, path, query) => {\n  const url = new URL(base);\n  url.pathname = (url.pathname + path).replace('//', '/');\n  if (query) {\n    url.search = buildSearchParams(query);\n  }\n  return url.toString();\n};\nvar version = '6.14.1';\nconst LIBRARY_NAME = 'UploadcareUploadClient';\nconst LIBRARY_VERSION = version;\nfunction getUserAgent(options) {\n  return getUserAgent$1({\n    libraryName: LIBRARY_NAME,\n    libraryVersion: LIBRARY_VERSION,\n    ...options\n  });\n}\nconst REQUEST_WAS_THROTTLED_CODE = 'RequestThrottledError';\nconst DEFAULT_RETRY_AFTER_TIMEOUT = 15000;\nconst DEFAULT_NETWORK_ERROR_TIMEOUT = 1000;\nfunction getTimeoutFromThrottledRequest(error) {\n  const {\n    headers\n  } = error || {};\n  if (!headers || typeof headers['retry-after'] !== 'string') {\n    return DEFAULT_RETRY_AFTER_TIMEOUT;\n  }\n  const seconds = parseInt(headers['retry-after'], 10);\n  if (!Number.isFinite(seconds)) {\n    return DEFAULT_RETRY_AFTER_TIMEOUT;\n  }\n  return seconds * 1000;\n}\nfunction retryIfFailed(fn, options) {\n  const {\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  } = options;\n  return retrier(({\n    attempt,\n    retry\n  }) => fn().catch(error => {\n    if ('response' in error && error?.code === REQUEST_WAS_THROTTLED_CODE && attempt < retryThrottledRequestMaxTimes) {\n      return retry(getTimeoutFromThrottledRequest(error));\n    }\n    if (error instanceof NetworkError && attempt < retryNetworkErrorMaxTimes) {\n      return retry((attempt + 1) * DEFAULT_NETWORK_ERROR_TIMEOUT);\n    }\n    throw error;\n  }));\n}\nconst getContentType = file => {\n  let contentType = '';\n  if (isBlob(file) || isFile(file) || isReactNativeAsset(file)) {\n    contentType = file.type;\n  }\n  return contentType || defaultContentType;\n};\nconst getFileName = file => {\n  let filename = '';\n  if (isFile(file) && file.name) {\n    filename = file.name;\n  } else if (isBlob(file) || isBuffer()) {\n    filename = '';\n  } else if (isReactNativeAsset(file) && file.name) {\n    filename = file.name;\n  }\n  return filename || defaultFilename;\n};\nfunction getStoreValue(store) {\n  if (typeof store === 'undefined' || store === 'auto') {\n    return 'auto';\n  }\n  return store ? '1' : '0';\n}\n\n/**\n * Performs file uploading request to Uploadcare Upload API. Can be canceled and\n * has progress.\n */\nfunction base(file, {\n  publicKey,\n  fileName,\n  contentType,\n  baseURL = defaultSettings.baseURL,\n  secureSignature,\n  secureExpire,\n  store,\n  signal,\n  onProgress,\n  source = 'local',\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes,\n  metadata\n}) {\n  return retryIfFailed(() => request({\n    method: 'POST',\n    url: getUrl(baseURL, '/base/', {\n      jsonerrors: 1\n    }),\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    data: buildFormData({\n      file: {\n        data: file,\n        name: fileName || getFileName(file),\n        contentType: contentType || getContentType(file)\n      },\n      UPLOADCARE_PUB_KEY: publicKey,\n      UPLOADCARE_STORE: getStoreValue(store),\n      signature: secureSignature,\n      expire: secureExpire,\n      source: source,\n      metadata\n    }),\n    signal,\n    onProgress\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryNetworkErrorMaxTimes,\n    retryThrottledRequestMaxTimes\n  });\n}\nvar TypeEnum;\n(function (TypeEnum) {\n  TypeEnum[\"Token\"] = \"token\";\n  TypeEnum[\"FileInfo\"] = \"file_info\";\n})(TypeEnum || (TypeEnum = {}));\n/** Uploading files from URL. */\nfunction fromUrl(sourceUrl, {\n  publicKey,\n  baseURL = defaultSettings.baseURL,\n  store,\n  fileName,\n  checkForUrlDuplicates,\n  saveUrlForRecurrentUploads,\n  secureSignature,\n  secureExpire,\n  source = 'url',\n  signal,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes,\n  metadata\n}) {\n  return retryIfFailed(() => request({\n    method: 'POST',\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    url: getUrl(baseURL, '/from_url/', {\n      jsonerrors: 1,\n      pub_key: publicKey,\n      source_url: sourceUrl,\n      store: getStoreValue(store),\n      filename: fileName,\n      check_URL_duplicates: checkForUrlDuplicates ? 1 : undefined,\n      save_URL_duplicates: saveUrlForRecurrentUploads ? 1 : undefined,\n      signature: secureSignature,\n      expire: secureExpire,\n      source: source,\n      metadata\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryNetworkErrorMaxTimes,\n    retryThrottledRequestMaxTimes\n  });\n}\nvar Status;\n(function (Status) {\n  Status[\"Unknown\"] = \"unknown\";\n  Status[\"Waiting\"] = \"waiting\";\n  Status[\"Progress\"] = \"progress\";\n  Status[\"Error\"] = \"error\";\n  Status[\"Success\"] = \"success\";\n})(Status || (Status = {}));\nconst isErrorResponse = response => {\n  return 'status' in response && response.status === Status.Error;\n};\n/** Checking upload status and working with file tokens. */\nfunction fromUrlStatus(token, {\n  publicKey,\n  baseURL = defaultSettings.baseURL,\n  signal,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes\n} = {}) {\n  return retryIfFailed(() => request({\n    method: 'GET',\n    headers: publicKey ? {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    } : undefined,\n    url: getUrl(baseURL, '/from_url/status/', {\n      jsonerrors: 1,\n      token\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response && !isErrorResponse(response)) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryNetworkErrorMaxTimes,\n    retryThrottledRequestMaxTimes\n  });\n}\n\n/** Create files group. */\nfunction group(uuids, {\n  publicKey,\n  baseURL = defaultSettings.baseURL,\n  jsonpCallback,\n  secureSignature,\n  secureExpire,\n  signal,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes\n}) {\n  return retryIfFailed(() => request({\n    method: 'POST',\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    url: getUrl(baseURL, '/group/', {\n      jsonerrors: 1\n    }),\n    data: buildFormData({\n      files: uuids,\n      callback: jsonpCallback,\n      pub_key: publicKey,\n      signature: secureSignature,\n      expire: secureExpire,\n      source\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryNetworkErrorMaxTimes,\n    retryThrottledRequestMaxTimes\n  });\n}\n\n/** Get info about group. */\nfunction groupInfo(id, {\n  publicKey,\n  baseURL = defaultSettings.baseURL,\n  signal,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes\n}) {\n  return retryIfFailed(() => request({\n    method: 'GET',\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    url: getUrl(baseURL, '/group/info/', {\n      jsonerrors: 1,\n      pub_key: publicKey,\n      group_id: id,\n      source\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  });\n}\n\n/** Returns a JSON dictionary holding file info. */\nfunction info(uuid, {\n  publicKey,\n  baseURL = defaultSettings.baseURL,\n  signal,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes\n}) {\n  return retryIfFailed(() => request({\n    method: 'GET',\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    url: getUrl(baseURL, '/info/', {\n      jsonerrors: 1,\n      pub_key: publicKey,\n      file_id: uuid,\n      source\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  });\n}\n\n/** Start multipart uploading. */\nfunction multipartStart(size, {\n  publicKey,\n  contentType,\n  fileName,\n  multipartChunkSize = defaultSettings.multipartChunkSize,\n  baseURL = '',\n  secureSignature,\n  secureExpire,\n  store,\n  signal,\n  source = 'local',\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes,\n  metadata\n}) {\n  return retryIfFailed(() => request({\n    method: 'POST',\n    url: getUrl(baseURL, '/multipart/start/', {\n      jsonerrors: 1\n    }),\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    data: buildFormData({\n      filename: fileName || defaultFilename,\n      size: size,\n      content_type: contentType || defaultContentType,\n      part_size: multipartChunkSize,\n      UPLOADCARE_STORE: getStoreValue(store),\n      UPLOADCARE_PUB_KEY: publicKey,\n      signature: secureSignature,\n      expire: secureExpire,\n      source: source,\n      metadata\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      // convert to array\n      response.parts = Object.keys(response.parts).map(key => response.parts[Number(key)]);\n      return response;\n    }\n  }), {\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  });\n}\n\n/** Complete multipart uploading. */\nfunction multipartUpload(part, url, {\n  contentType,\n  signal,\n  onProgress,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes\n}) {\n  return retryIfFailed(() => request({\n    method: 'PUT',\n    url,\n    data: part,\n    // Upload request can't be non-computable because we always know exact size\n    onProgress: onProgress,\n    signal,\n    headers: {\n      'Content-Type': contentType || defaultContentType\n    }\n  }).then(result => {\n    // hack for node ¯\\_(ツ)_/¯\n    if (onProgress) onProgress({\n      isComputable: true,\n      value: 1\n    });\n    return result;\n  }).then(({\n    status\n  }) => ({\n    code: status\n  })), {\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  });\n}\n\n/** Complete multipart uploading. */\nfunction multipartComplete(uuid, {\n  publicKey,\n  baseURL = defaultSettings.baseURL,\n  source = 'local',\n  signal,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes\n}) {\n  return retryIfFailed(() => request({\n    method: 'POST',\n    url: getUrl(baseURL, '/multipart/complete/', {\n      jsonerrors: 1\n    }),\n    headers: {\n      'X-UC-User-Agent': getUserAgent({\n        publicKey,\n        integration,\n        userAgent\n      })\n    },\n    data: buildFormData({\n      uuid: uuid,\n      UPLOADCARE_PUB_KEY: publicKey,\n      source: source\n    }),\n    signal\n  }).then(({\n    data,\n    headers,\n    request\n  }) => {\n    const response = camelizeKeys(JSON.parse(data));\n    if ('error' in response) {\n      throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n    } else {\n      return response;\n    }\n  }), {\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  });\n}\nfunction isReadyPoll(uuid, {\n  publicKey,\n  baseURL,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes,\n  signal,\n  onProgress\n}) {\n  return poll({\n    check: signal => info(uuid, {\n      publicKey,\n      baseURL,\n      signal,\n      source,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      retryNetworkErrorMaxTimes\n    }).then(response => {\n      if (response.isReady) {\n        return response;\n      }\n      onProgress && onProgress({\n        isComputable: true,\n        value: 1\n      });\n      return false;\n    }),\n    signal\n  });\n}\nfunction isGroupFileInfo(fileInfo) {\n  return 'defaultEffects' in fileInfo;\n}\nclass UploadcareFile {\n  uuid;\n  name = null;\n  size = null;\n  isStored = null;\n  isImage = null;\n  mimeType = null;\n  cdnUrl = null;\n  s3Url = null;\n  originalFilename = null;\n  imageInfo = null;\n  videoInfo = null;\n  contentInfo = null;\n  metadata = null;\n  s3Bucket = null;\n  defaultEffects = null;\n  constructor(fileInfo, {\n    baseCDN = defaultSettings.baseCDN,\n    fileName\n  } = {}) {\n    const {\n      uuid,\n      s3Bucket\n    } = fileInfo;\n    const cdnUrl = getUrl(baseCDN, `${uuid}/`);\n    const s3Url = s3Bucket ? getUrl(`https://${s3Bucket}.s3.amazonaws.com/`, `${uuid}/${fileInfo.filename}`) : null;\n    this.uuid = uuid;\n    this.name = fileName || fileInfo.filename;\n    this.size = fileInfo.size;\n    this.isStored = fileInfo.isStored;\n    this.isImage = fileInfo.isImage;\n    this.mimeType = fileInfo.mimeType;\n    this.cdnUrl = cdnUrl;\n    this.originalFilename = fileInfo.originalFilename;\n    this.imageInfo = fileInfo.imageInfo;\n    this.videoInfo = fileInfo.videoInfo;\n    this.contentInfo = fileInfo.contentInfo;\n    this.metadata = fileInfo.metadata || null;\n    this.s3Bucket = s3Bucket || null;\n    this.s3Url = s3Url;\n    if (isGroupFileInfo(fileInfo)) {\n      this.defaultEffects = fileInfo.defaultEffects;\n    }\n  }\n}\nconst uploadDirect = (file, {\n  publicKey,\n  fileName,\n  baseURL,\n  secureSignature,\n  secureExpire,\n  store,\n  contentType,\n  signal,\n  onProgress,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes,\n  baseCDN,\n  metadata\n}) => {\n  return base(file, {\n    publicKey,\n    fileName,\n    contentType,\n    baseURL,\n    secureSignature,\n    secureExpire,\n    store,\n    signal,\n    onProgress,\n    source,\n    integration,\n    userAgent,\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes,\n    metadata\n  }).then(({\n    file\n  }) => {\n    return isReadyPoll(file, {\n      publicKey,\n      baseURL,\n      source,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      retryNetworkErrorMaxTimes,\n      onProgress,\n      signal\n    });\n  }).then(fileInfo => new UploadcareFile(fileInfo, {\n    baseCDN\n  }));\n};\nconst uploadFromUploaded = (uuid, {\n  publicKey,\n  fileName,\n  baseURL,\n  signal,\n  onProgress,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes,\n  baseCDN\n}) => {\n  return info(uuid, {\n    publicKey,\n    baseURL,\n    signal,\n    source,\n    integration,\n    userAgent,\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n  }).then(fileInfo => new UploadcareFile(fileInfo, {\n    baseCDN,\n    fileName\n  })).then(result => {\n    // hack for node ¯\\_(ツ)_/¯\n    if (onProgress) onProgress({\n      isComputable: true,\n      value: 1\n    });\n    return result;\n  });\n};\nconst race = (fns, {\n  signal\n} = {}) => {\n  let lastError = null;\n  let winnerIndex = null;\n  const controllers = fns.map(() => new AbortController());\n  const createStopRaceCallback = i => () => {\n    winnerIndex = i;\n    controllers.forEach((controller, index) => index !== i && controller.abort());\n  };\n  onCancel(signal, () => {\n    controllers.forEach(controller => controller.abort());\n  });\n  return Promise.all(fns.map((fn, i) => {\n    const stopRace = createStopRaceCallback(i);\n    return Promise.resolve().then(() => fn({\n      stopRace,\n      signal: controllers[i].signal\n    })).then(result => {\n      stopRace();\n      return result;\n    }).catch(error => {\n      lastError = error;\n      return null;\n    });\n  })).then(results => {\n    if (winnerIndex === null) {\n      throw lastError;\n    } else {\n      return results[winnerIndex];\n    }\n  });\n};\nvar WebSocket = window.WebSocket;\nclass Events {\n  events = Object.create({});\n  emit(event, data) {\n    this.events[event]?.forEach(fn => fn(data));\n  }\n  on(event, callback) {\n    this.events[event] = this.events[event] || [];\n    this.events[event].push(callback);\n  }\n  off(event, callback) {\n    if (callback) {\n      this.events[event] = this.events[event].filter(fn => fn !== callback);\n    } else {\n      this.events[event] = [];\n    }\n  }\n}\nconst response = (type, data) => {\n  if (type === 'success') {\n    return {\n      status: Status.Success,\n      ...data\n    };\n  }\n  if (type === 'progress') {\n    return {\n      status: Status.Progress,\n      ...data\n    };\n  }\n  return {\n    status: Status.Error,\n    ...data\n  };\n};\nclass Pusher {\n  key;\n  disconnectTime;\n  ws = undefined;\n  queue = [];\n  isConnected = false;\n  subscribers = 0;\n  emmitter = new Events();\n  disconnectTimeoutId = null;\n  constructor(pusherKey, disconnectTime = 30000) {\n    this.key = pusherKey;\n    this.disconnectTime = disconnectTime;\n  }\n  connect() {\n    this.disconnectTimeoutId && clearTimeout(this.disconnectTimeoutId);\n    if (!this.isConnected && !this.ws) {\n      const pusherUrl = `wss://ws.pusherapp.com/app/${this.key}?protocol=5&client=js&version=1.12.2`;\n      this.ws = new WebSocket(pusherUrl);\n      this.ws.addEventListener('error', error => {\n        this.emmitter.emit('error', new Error(error.message));\n      });\n      this.emmitter.on('connected', () => {\n        this.isConnected = true;\n        this.queue.forEach(message => this.send(message.event, message.data));\n        this.queue = [];\n      });\n      this.ws.addEventListener('message', e => {\n        const data = JSON.parse(e.data.toString());\n        switch (data.event) {\n          case 'pusher:connection_established':\n            {\n              this.emmitter.emit('connected', undefined);\n              break;\n            }\n          case 'pusher:ping':\n            {\n              this.send('pusher:pong', {});\n              break;\n            }\n          case 'progress':\n          case 'success':\n          case 'fail':\n            {\n              this.emmitter.emit(data.channel, response(data.event, JSON.parse(data.data)));\n            }\n        }\n      });\n    }\n  }\n  disconnect() {\n    const actualDisconect = () => {\n      this.ws?.close();\n      this.ws = undefined;\n      this.isConnected = false;\n    };\n    if (this.disconnectTime) {\n      this.disconnectTimeoutId = setTimeout(() => {\n        actualDisconect();\n      }, this.disconnectTime);\n    } else {\n      actualDisconect();\n    }\n  }\n  send(event, data) {\n    const str = JSON.stringify({\n      event,\n      data\n    });\n    this.ws?.send(str);\n  }\n  subscribe(token, handler) {\n    this.subscribers += 1;\n    this.connect();\n    const channel = `task-status-${token}`;\n    const message = {\n      event: 'pusher:subscribe',\n      data: {\n        channel\n      }\n    };\n    this.emmitter.on(channel, handler);\n    if (this.isConnected) {\n      this.send(message.event, message.data);\n    } else {\n      this.queue.push(message);\n    }\n  }\n  unsubscribe(token) {\n    this.subscribers -= 1;\n    const channel = `task-status-${token}`;\n    const message = {\n      event: 'pusher:unsubscribe',\n      data: {\n        channel\n      }\n    };\n    this.emmitter.off(channel);\n    if (this.isConnected) {\n      this.send(message.event, message.data);\n    } else {\n      this.queue = this.queue.filter(msg => msg.data.channel !== channel);\n    }\n    if (this.subscribers === 0) {\n      this.disconnect();\n    }\n  }\n  onError(callback) {\n    this.emmitter.on('error', callback);\n    return () => this.emmitter.off('error', callback);\n  }\n}\nlet pusher = null;\nconst getPusher = key => {\n  if (!pusher) {\n    // no timeout for nodeJS and 30000 ms for browser\n    const disconectTimeout = typeof window === 'undefined' ? 0 : 30000;\n    pusher = new Pusher(key, disconectTimeout);\n  }\n  return pusher;\n};\nconst preconnect = key => {\n  getPusher(key).connect();\n};\nfunction pollStrategy({\n  token,\n  publicKey,\n  baseURL,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes,\n  onProgress,\n  signal\n}) {\n  return poll({\n    check: signal => fromUrlStatus(token, {\n      publicKey,\n      baseURL,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      retryNetworkErrorMaxTimes,\n      signal\n    }).then(response => {\n      switch (response.status) {\n        case Status.Error:\n          {\n            return new UploadError(response.error, response.errorCode);\n          }\n        case Status.Waiting:\n          {\n            return false;\n          }\n        case Status.Unknown:\n          {\n            return new UploadError(`Token \"${token}\" was not found.`);\n          }\n        case Status.Progress:\n          {\n            if (onProgress) {\n              if (response.total === 'unknown') {\n                onProgress({\n                  isComputable: false\n                });\n              } else {\n                onProgress({\n                  isComputable: true,\n                  value: response.done / response.total\n                });\n              }\n            }\n            return false;\n          }\n        case Status.Success:\n          {\n            if (onProgress) onProgress({\n              isComputable: true,\n              value: response.done / response.total\n            });\n            return response;\n          }\n        default:\n          {\n            throw new Error('Unknown status');\n          }\n      }\n    }),\n    signal\n  });\n}\nconst pushStrategy = ({\n  token,\n  pusherKey,\n  signal,\n  onProgress\n}) => new Promise((resolve, reject) => {\n  const pusher = getPusher(pusherKey);\n  const unsubErrorHandler = pusher.onError(reject);\n  const destroy = () => {\n    unsubErrorHandler();\n    pusher.unsubscribe(token);\n  };\n  onCancel(signal, () => {\n    destroy();\n    reject(new CancelError('pusher cancelled'));\n  });\n  pusher.subscribe(token, result => {\n    switch (result.status) {\n      case Status.Progress:\n        {\n          if (onProgress) {\n            if (result.total === 'unknown') {\n              onProgress({\n                isComputable: false\n              });\n            } else {\n              onProgress({\n                isComputable: true,\n                value: result.done / result.total\n              });\n            }\n          }\n          break;\n        }\n      case Status.Success:\n        {\n          destroy();\n          if (onProgress) onProgress({\n            isComputable: true,\n            value: result.done / result.total\n          });\n          resolve(result);\n          break;\n        }\n      case Status.Error:\n        {\n          destroy();\n          reject(new UploadError(result.msg, result.error_code));\n        }\n    }\n  });\n});\nconst uploadFromUrl = (sourceUrl, {\n  publicKey,\n  fileName,\n  baseURL,\n  baseCDN,\n  checkForUrlDuplicates,\n  saveUrlForRecurrentUploads,\n  secureSignature,\n  secureExpire,\n  store,\n  signal,\n  onProgress,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  pusherKey = defaultSettings.pusherKey,\n  metadata\n}) => Promise.resolve(preconnect(pusherKey)).then(() => fromUrl(sourceUrl, {\n  publicKey,\n  fileName,\n  baseURL,\n  checkForUrlDuplicates,\n  saveUrlForRecurrentUploads,\n  secureSignature,\n  secureExpire,\n  store,\n  signal,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  metadata\n})).catch(error => {\n  const pusher = getPusher(pusherKey);\n  pusher?.disconnect();\n  return Promise.reject(error);\n}).then(urlResponse => {\n  if (urlResponse.type === TypeEnum.FileInfo) {\n    return urlResponse;\n  } else {\n    return race([({\n      signal\n    }) => pollStrategy({\n      token: urlResponse.token,\n      publicKey,\n      baseURL,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      onProgress,\n      signal\n    }), ({\n      signal\n    }) => pushStrategy({\n      token: urlResponse.token,\n      pusherKey,\n      signal,\n      onProgress\n    })], {\n      signal\n    });\n  }\n}).then(result => {\n  if (result instanceof UploadError) throw result;\n  return result;\n}).then(result => isReadyPoll(result.uuid, {\n  publicKey,\n  baseURL,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  onProgress,\n  signal\n})).then(fileInfo => new UploadcareFile(fileInfo, {\n  baseCDN\n}));\nconst memo = new WeakMap();\nconst getBlobFromReactNativeAsset = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (asset) {\n    if (memo.has(asset)) {\n      return memo.get(asset);\n    }\n    const blob = yield fetch(asset.uri).then(res => res.blob());\n    memo.set(asset, blob);\n    return blob;\n  });\n  return function getBlobFromReactNativeAsset(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nconst getFileSize = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (file) {\n    if (isFile(file) || isBlob(file)) {\n      return file.size;\n    }\n    if (isReactNativeAsset(file)) {\n      const blob = yield getBlobFromReactNativeAsset(file);\n      return blob.size;\n    }\n    throw new Error(`Unknown file type. Cannot determine file size.`);\n  });\n  return function getFileSize(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/** Check if FileData is multipart data. */\nconst isMultipart = (fileSize, multipartMinFileSize = defaultSettings.multipartMinFileSize) => {\n  return fileSize >= multipartMinFileSize;\n};\n\n/** Uuid type guard. */\nconst isUuid = data => {\n  const UUID_REGEX = '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}';\n  const regExp = new RegExp(UUID_REGEX);\n  return !isFileData(data) && regExp.test(data);\n};\n/**\n * Url type guard.\n *\n * @param {SupportedFileInput | Url | Uuid} data\n */\nconst isUrl = data => {\n  const URL_REGEX = '^(?:\\\\w+:)?\\\\/\\\\/([^\\\\s\\\\.]+\\\\.\\\\S{2}|localhost[\\\\:?\\\\d]*)\\\\S*$';\n  const regExp = new RegExp(URL_REGEX);\n  return !isFileData(data) && regExp.test(data);\n};\nconst runWithConcurrency = (concurrency, tasks) => {\n  return new Promise((resolve, reject) => {\n    const results = [];\n    let rejected = false;\n    let settled = tasks.length;\n    const forRun = [...tasks];\n    const run = () => {\n      const index = tasks.length - forRun.length;\n      const next = forRun.shift();\n      if (next) {\n        next().then(result => {\n          if (rejected) return;\n          results[index] = result;\n          settled -= 1;\n          if (settled) {\n            run();\n          } else {\n            resolve(results);\n          }\n        }).catch(error => {\n          rejected = true;\n          reject(error);\n        });\n      }\n    };\n    for (let i = 0; i < concurrency; i++) {\n      run();\n    }\n  });\n};\nconst sliceChunk = (file, index, fileSize, chunkSize) => {\n  const start = chunkSize * index;\n  const end = Math.min(start + chunkSize, fileSize);\n  return file.slice(start, end);\n};\nconst prepareChunks = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (file, fileSize, chunkSize) {\n    return index => sliceChunk(file, index, fileSize, chunkSize);\n  });\n  return function prepareChunks(_x3, _x4, _x5) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nconst uploadPart = (chunk, url, {\n  publicKey,\n  contentType,\n  onProgress,\n  signal,\n  integration,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes\n}) => multipartUpload(chunk, url, {\n  publicKey,\n  contentType,\n  onProgress,\n  signal,\n  integration,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes\n});\nconst uploadMultipart = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (file, {\n    publicKey,\n    fileName,\n    fileSize,\n    baseURL,\n    secureSignature,\n    secureExpire,\n    store,\n    signal,\n    onProgress,\n    source,\n    integration,\n    userAgent,\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes,\n    contentType,\n    multipartChunkSize = defaultSettings.multipartChunkSize,\n    maxConcurrentRequests = defaultSettings.maxConcurrentRequests,\n    baseCDN,\n    metadata\n  }) {\n    const size = fileSize ?? (yield getFileSize(file));\n    let progressValues;\n    const createProgressHandler = (totalChunks, chunkIdx) => {\n      if (!onProgress) return;\n      if (!progressValues) {\n        progressValues = Array(totalChunks).fill(0);\n      }\n      const sum = values => values.reduce((sum, next) => sum + next, 0);\n      return info => {\n        if (!info.isComputable) {\n          return;\n        }\n        progressValues[chunkIdx] = info.value;\n        onProgress({\n          isComputable: true,\n          value: sum(progressValues) / totalChunks\n        });\n      };\n    };\n    contentType ||= getContentType(file);\n    return multipartStart(size, {\n      publicKey,\n      contentType,\n      fileName: fileName || getFileName(file),\n      baseURL,\n      secureSignature,\n      secureExpire,\n      store,\n      signal,\n      source,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      retryNetworkErrorMaxTimes,\n      metadata\n    }).then( /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* ({\n        uuid,\n        parts\n      }) {\n        const getChunk = yield prepareChunks(file, size, multipartChunkSize);\n        return Promise.all([uuid, runWithConcurrency(maxConcurrentRequests, parts.map((url, index) => () => uploadPart(getChunk(index), url, {\n          publicKey,\n          contentType,\n          onProgress: createProgressHandler(parts.length, index),\n          signal,\n          integration,\n          retryThrottledRequestMaxTimes,\n          retryNetworkErrorMaxTimes\n        })))]);\n      });\n      return function (_x8) {\n        return _ref5.apply(this, arguments);\n      };\n    }()).then(([uuid]) => multipartComplete(uuid, {\n      publicKey,\n      baseURL,\n      source,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      retryNetworkErrorMaxTimes\n    })).then(fileInfo => {\n      if (fileInfo.isReady) {\n        return fileInfo;\n      } else {\n        return isReadyPoll(fileInfo.uuid, {\n          publicKey,\n          baseURL,\n          source,\n          integration,\n          userAgent,\n          retryThrottledRequestMaxTimes,\n          retryNetworkErrorMaxTimes,\n          onProgress,\n          signal\n        });\n      }\n    }).then(fileInfo => new UploadcareFile(fileInfo, {\n      baseCDN\n    }));\n  });\n  return function uploadMultipart(_x6, _x7) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\n/** Uploads file from provided data. */\nfunction uploadFile(_x9, _x10) {\n  return _uploadFile.apply(this, arguments);\n}\nfunction _uploadFile() {\n  _uploadFile = _asyncToGenerator(function* (data, {\n    publicKey,\n    fileName,\n    baseURL = defaultSettings.baseURL,\n    secureSignature,\n    secureExpire,\n    store,\n    signal,\n    onProgress,\n    source,\n    integration,\n    userAgent,\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes,\n    contentType,\n    multipartMinFileSize,\n    multipartChunkSize,\n    maxConcurrentRequests,\n    baseCDN = defaultSettings.baseCDN,\n    checkForUrlDuplicates,\n    saveUrlForRecurrentUploads,\n    pusherKey,\n    metadata\n  }) {\n    if (isFileData(data)) {\n      const fileSize = yield getFileSize(data);\n      if (isMultipart(fileSize, multipartMinFileSize)) {\n        return uploadMultipart(data, {\n          publicKey,\n          contentType,\n          multipartChunkSize,\n          fileSize,\n          fileName,\n          baseURL,\n          secureSignature,\n          secureExpire,\n          store,\n          signal,\n          onProgress,\n          source,\n          integration,\n          userAgent,\n          maxConcurrentRequests,\n          retryThrottledRequestMaxTimes,\n          retryNetworkErrorMaxTimes,\n          baseCDN,\n          metadata\n        });\n      }\n      return uploadDirect(data, {\n        publicKey,\n        fileName,\n        contentType,\n        baseURL,\n        secureSignature,\n        secureExpire,\n        store,\n        signal,\n        onProgress,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes,\n        baseCDN,\n        metadata\n      });\n    }\n    if (isUrl(data)) {\n      return uploadFromUrl(data, {\n        publicKey,\n        fileName,\n        baseURL,\n        baseCDN,\n        checkForUrlDuplicates,\n        saveUrlForRecurrentUploads,\n        secureSignature,\n        secureExpire,\n        store,\n        signal,\n        onProgress,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes,\n        pusherKey,\n        metadata\n      });\n    }\n    if (isUuid(data)) {\n      return uploadFromUploaded(data, {\n        publicKey,\n        fileName,\n        baseURL,\n        signal,\n        onProgress,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes,\n        baseCDN\n      });\n    }\n    throw new TypeError(`File uploading from \"${data}\" is not supported`);\n  });\n  return _uploadFile.apply(this, arguments);\n}\nclass UploadcareGroup {\n  uuid;\n  filesCount;\n  totalSize;\n  isStored;\n  isImage;\n  cdnUrl;\n  files;\n  createdAt;\n  storedAt = null;\n  constructor(groupInfo, {\n    baseCDN = defaultSettings.baseCDN\n  } = {}) {\n    this.uuid = groupInfo.id;\n    this.filesCount = groupInfo.filesCount;\n    const groupFiles = groupInfo.files.filter(Boolean);\n    this.totalSize = Object.values(groupFiles).reduce((acc, file) => acc + file.size, 0);\n    this.isStored = !!groupInfo.datetimeStored;\n    this.isImage = !!Object.values(groupFiles).filter(file => file.isImage).length;\n    this.cdnUrl = groupInfo.cdnUrl;\n    this.files = groupFiles.map(fileInfo => new UploadcareFile(fileInfo, {\n      baseCDN\n    }));\n    this.createdAt = groupInfo.datetimeCreated;\n    this.storedAt = groupInfo.datetimeStored;\n  }\n}\n\n/** FileData type guard. */\nconst isFileDataArray = data => {\n  for (const item of data) {\n    if (!isFileData(item)) {\n      return false;\n    }\n  }\n  return true;\n};\n/** Uuid type guard. */\nconst isUuidArray = data => {\n  for (const item of data) {\n    if (!isUuid(item)) {\n      return false;\n    }\n  }\n  return true;\n};\n/** Url type guard. */\nconst isUrlArray = data => {\n  for (const item of data) {\n    if (!isUrl(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction uploadFileGroup(data, {\n  publicKey,\n  fileName,\n  baseURL = defaultSettings.baseURL,\n  secureSignature,\n  secureExpire,\n  store,\n  signal,\n  onProgress,\n  source,\n  integration,\n  userAgent,\n  retryThrottledRequestMaxTimes,\n  retryNetworkErrorMaxTimes,\n  contentType,\n  multipartChunkSize = defaultSettings.multipartChunkSize,\n  baseCDN = defaultSettings.baseCDN,\n  checkForUrlDuplicates,\n  saveUrlForRecurrentUploads,\n  jsonpCallback\n}) {\n  if (!isFileDataArray(data) && !isUrlArray(data) && !isUuidArray(data)) {\n    throw new TypeError(`Group uploading from \"${data}\" is not supported`);\n  }\n  let progressValues;\n  let isStillComputable = true;\n  const filesCount = data.length;\n  const createProgressHandler = (size, index) => {\n    if (!onProgress) return;\n    if (!progressValues) {\n      progressValues = Array(size).fill(0);\n    }\n    const normalize = values => values.reduce((sum, next) => sum + next) / size;\n    return info => {\n      if (!info.isComputable || !isStillComputable) {\n        isStillComputable = false;\n        onProgress({\n          isComputable: false\n        });\n        return;\n      }\n      progressValues[index] = info.value;\n      onProgress({\n        isComputable: true,\n        value: normalize(progressValues)\n      });\n    };\n  };\n  return Promise.all(data.map((file, index) => {\n    if (isFileData(file) || isUrl(file)) {\n      return uploadFile(file, {\n        publicKey,\n        fileName,\n        baseURL,\n        secureSignature,\n        secureExpire,\n        store,\n        signal,\n        onProgress: createProgressHandler(filesCount, index),\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes,\n        contentType,\n        multipartChunkSize,\n        baseCDN,\n        checkForUrlDuplicates,\n        saveUrlForRecurrentUploads\n      }).then(fileInfo => fileInfo.uuid);\n    } else {\n      // Do not request file info by uuid before creating group because this isn't necessary\n      return file;\n    }\n  })).then(uuids => {\n    return group(uuids, {\n      publicKey,\n      baseURL,\n      jsonpCallback,\n      secureSignature,\n      secureExpire,\n      signal,\n      source,\n      integration,\n      userAgent,\n      retryThrottledRequestMaxTimes,\n      retryNetworkErrorMaxTimes\n    }).then(groupInfo => new UploadcareGroup(groupInfo, {\n      baseCDN\n    })).then(group => {\n      onProgress && onProgress({\n        isComputable: true,\n        value: 1\n      });\n      return group;\n    });\n  });\n}\n\n/** Populate options with settings. */\nconst populateOptionsWithSettings = (options, settings) => ({\n  ...settings,\n  ...options\n});\nclass UploadClient {\n  settings;\n  constructor(settings) {\n    this.settings = Object.assign({}, defaultSettings, settings);\n  }\n  updateSettings(newSettings) {\n    this.settings = Object.assign(this.settings, newSettings);\n  }\n  getSettings() {\n    return this.settings;\n  }\n  base(file, options = {}) {\n    const settings = this.getSettings();\n    return base(file, populateOptionsWithSettings(options, settings));\n  }\n  info(uuid, options = {}) {\n    const settings = this.getSettings();\n    return info(uuid, populateOptionsWithSettings(options, settings));\n  }\n  fromUrl(sourceUrl, options = {}) {\n    const settings = this.getSettings();\n    return fromUrl(sourceUrl, populateOptionsWithSettings(options, settings));\n  }\n  fromUrlStatus(token, options = {}) {\n    const settings = this.getSettings();\n    return fromUrlStatus(token, populateOptionsWithSettings(options, settings));\n  }\n  group(uuids, options = {}) {\n    const settings = this.getSettings();\n    return group(uuids, populateOptionsWithSettings(options, settings));\n  }\n  groupInfo(id, options = {}) {\n    const settings = this.getSettings();\n    return groupInfo(id, populateOptionsWithSettings(options, settings));\n  }\n  multipartStart(size, options = {}) {\n    const settings = this.getSettings();\n    return multipartStart(size, populateOptionsWithSettings(options, settings));\n  }\n  multipartUpload(part, url, options = {}) {\n    const settings = this.getSettings();\n    return multipartUpload(part, url, populateOptionsWithSettings(options, settings));\n  }\n  multipartComplete(uuid, options = {}) {\n    const settings = this.getSettings();\n    return multipartComplete(uuid, populateOptionsWithSettings(options, settings));\n  }\n  uploadFile(data, options = {}) {\n    const settings = this.getSettings();\n    return uploadFile(data, populateOptionsWithSettings(options, settings));\n  }\n  uploadFileGroup(data, options = {}) {\n    const settings = this.getSettings();\n    return uploadFileGroup(data, populateOptionsWithSettings(options, settings));\n  }\n  isReadyPoll(uuid, options = {}) {\n    const settings = this.getSettings();\n    return isReadyPoll(uuid, populateOptionsWithSettings(options, settings));\n  }\n}\nclass Queue {\n  _concurrency = 1;\n  _pending = [];\n  _running = 0;\n  _resolvers = new Map();\n  _rejectors = new Map();\n  constructor(concurrency) {\n    this._concurrency = concurrency;\n  }\n  _run() {\n    const tasksLeft = this._concurrency - this._running;\n    for (let i = 0; i < tasksLeft; i++) {\n      const task = this._pending.shift();\n      if (!task) {\n        return;\n      }\n      const resolver = this._resolvers.get(task);\n      const rejector = this._rejectors.get(task);\n      if (!resolver || !rejector) throw new Error('Unexpected behavior: resolver or rejector is undefined');\n      this._running += 1;\n      task().finally(() => {\n        this._resolvers.delete(task);\n        this._rejectors.delete(task);\n        this._running -= 1;\n        this._run();\n      }).then(value => resolver(value)).catch(error => rejector(error));\n    }\n  }\n  add(task) {\n    return new Promise((resolve, reject) => {\n      this._resolvers.set(task, resolve);\n      this._rejectors.set(task, reject);\n      this._pending.push(task);\n      this._run();\n    });\n  }\n  get pending() {\n    return this._pending.length;\n  }\n  get running() {\n    return this._running;\n  }\n  set concurrency(value) {\n    this._concurrency = value;\n    this._run();\n  }\n  get concurrency() {\n    return this._concurrency;\n  }\n}\n\n/* Low-Level API */\n/** @deprecated Please use NetworkError instead. */\nconst UploadcareNetworkError = NetworkError;\n/** @deprecated Please use UploadError instead. */\nconst UploadClientError = UploadError;\nexport { CancelError, NetworkError, Queue, UploadClient, UploadClientError, UploadError, UploadcareError, UploadcareFile, UploadcareGroup, UploadcareNetworkError, base, fromUrl, fromUrlStatus, getUserAgent$1 as getUserAgent, group, groupInfo, info, isReadyPoll, multipartComplete, multipartStart, multipartUpload, uploadDirect, uploadFile, uploadFileGroup, uploadFromUploaded, uploadFromUrl, uploadMultipart };","map":{"version":3,"names":["isObject","o","Object","prototype","toString","call","SEPARATOR","camelizeString","text","split","map","word","index","charAt","slice","join","camelizeArrayItems","array","ignoreKeys","Array","isArray","item","camelizeKeys","source","result","key","keys","value","includes","delay","ms","Promise","resolve","setTimeout","getUserAgent$1","libraryName","libraryVersion","userAgent","publicKey","integration","languageName","mainInfo","filter","Boolean","additionInfo","defaultOptions","factor","time","retrier","fn","options","attempts","runAttempt","defaultDelayTime","Math","round","retry","then","attempt","UploadcareError","Error","NetworkError","originalProgressEvent","constructor","progressEvent","name","message","setPrototypeOf","onCancel","signal","callback","aborted","addEventListener","once","CancelError","isCancel","DEFAULT_INTERVAL","poll","check","interval","timeout","reject","tickTimeoutId","timeoutId","clearTimeout","tick","catch","error","defaultSettings","baseCDN","baseURL","maxContentLength","retryThrottledRequestMaxTimes","retryNetworkErrorMaxTimes","multipartMinFileSize","multipartChunkSize","multipartMinLastPartSize","maxConcurrentRequests","pollingTimeoutMilliseconds","pusherKey","defaultContentType","defaultFilename","request","method","url","data","headers","onProgress","xhr","XMLHttpRequest","requestMethod","toUpperCase","open","entries","forEach","entry","setRequestHeader","responseType","abort","onload","status","statusText","undefined","headersArray","getAllResponseHeaders","trim","responseHeaders","line","parts","header","shift","responseData","response","responseStatus","onerror","upload","onprogress","event","lengthComputable","isComputable","loaded","total","send","identity","obj","_args","getFileOptions","transformFile","getFormData","FormData","isBuffer","isBlob","Blob","isFile","File","isReactNativeAsset","uri","isFileData","isSimpleValue","isObjectValue","isFileValue","collectParams","params","inputKey","inputValue","contentType","file","push","String","getFormDataParams","buildFormData","formData","paramsList","rest","append","UploadError","code","buildSearchParams","query","searchParams","URLSearchParams","set","val","getUrl","base","path","URL","pathname","replace","search","version","LIBRARY_NAME","LIBRARY_VERSION","getUserAgent","REQUEST_WAS_THROTTLED_CODE","DEFAULT_RETRY_AFTER_TIMEOUT","DEFAULT_NETWORK_ERROR_TIMEOUT","getTimeoutFromThrottledRequest","seconds","parseInt","Number","isFinite","retryIfFailed","getContentType","type","getFileName","filename","getStoreValue","store","fileName","secureSignature","secureExpire","metadata","jsonerrors","UPLOADCARE_PUB_KEY","UPLOADCARE_STORE","signature","expire","JSON","parse","content","errorCode","TypeEnum","fromUrl","sourceUrl","checkForUrlDuplicates","saveUrlForRecurrentUploads","pub_key","source_url","check_URL_duplicates","save_URL_duplicates","Status","isErrorResponse","fromUrlStatus","token","group","uuids","jsonpCallback","files","groupInfo","id","group_id","info","uuid","file_id","multipartStart","size","content_type","part_size","multipartUpload","part","multipartComplete","isReadyPoll","isReady","isGroupFileInfo","fileInfo","UploadcareFile","isStored","isImage","mimeType","cdnUrl","s3Url","originalFilename","imageInfo","videoInfo","contentInfo","s3Bucket","defaultEffects","uploadDirect","uploadFromUploaded","race","fns","lastError","winnerIndex","controllers","AbortController","createStopRaceCallback","i","controller","all","stopRace","results","WebSocket","window","Events","events","create","emit","on","off","Success","Progress","Pusher","disconnectTime","ws","queue","isConnected","subscribers","emmitter","disconnectTimeoutId","connect","pusherUrl","e","channel","disconnect","actualDisconect","close","str","stringify","subscribe","handler","unsubscribe","msg","onError","pusher","getPusher","disconectTimeout","preconnect","pollStrategy","Waiting","Unknown","done","pushStrategy","unsubErrorHandler","destroy","error_code","uploadFromUrl","urlResponse","FileInfo","memo","WeakMap","getBlobFromReactNativeAsset","_ref","_asyncToGenerator","asset","has","get","blob","fetch","res","_x","apply","arguments","getFileSize","_ref2","_x2","isMultipart","fileSize","isUuid","UUID_REGEX","regExp","RegExp","test","isUrl","URL_REGEX","runWithConcurrency","concurrency","tasks","rejected","settled","length","forRun","run","next","sliceChunk","chunkSize","start","end","min","prepareChunks","_ref3","_x3","_x4","_x5","uploadPart","chunk","uploadMultipart","_ref4","progressValues","createProgressHandler","totalChunks","chunkIdx","fill","sum","values","reduce","_ref5","getChunk","_x8","_x6","_x7","uploadFile","_x9","_x10","_uploadFile","TypeError","UploadcareGroup","filesCount","totalSize","createdAt","storedAt","groupFiles","acc","datetimeStored","datetimeCreated","isFileDataArray","isUuidArray","isUrlArray","uploadFileGroup","isStillComputable","normalize","populateOptionsWithSettings","settings","UploadClient","assign","updateSettings","newSettings","getSettings","Queue","_concurrency","_pending","_running","_resolvers","Map","_rejectors","_run","tasksLeft","task","resolver","rejector","finally","delete","add","pending","running","UploadcareNetworkError","UploadClientError"],"sources":["/Users/David/Documents/own_projects/mp4-to-gif/node_modules/@uploadcare/upload-client/dist/esm/index.browser.mjs"],"sourcesContent":["function isObject(o) {\n    return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nconst SEPARATOR = /\\W|_/g;\nfunction camelizeString(text) {\n    return text\n        .split(SEPARATOR)\n        .map((word, index) => word.charAt(0)[index > 0 ? 'toUpperCase' : 'toLowerCase']() +\n        word.slice(1))\n        .join('');\n}\nfunction camelizeArrayItems(array, { ignoreKeys } = { ignoreKeys: [] }) {\n    if (!Array.isArray(array)) {\n        return array;\n    }\n    return array.map((item) => camelizeKeys(item, { ignoreKeys }));\n}\nfunction camelizeKeys(source, { ignoreKeys } = { ignoreKeys: [] }) {\n    if (Array.isArray(source)) {\n        return camelizeArrayItems(source, { ignoreKeys });\n    }\n    if (!isObject(source)) {\n        return source;\n    }\n    const result = {};\n    for (const key of Object.keys(source)) {\n        let value = source[key];\n        if (ignoreKeys.includes(key)) {\n            result[key] = value;\n            continue;\n        }\n        if (isObject(value)) {\n            value = camelizeKeys(value, { ignoreKeys });\n        }\n        else if (Array.isArray(value)) {\n            value = camelizeArrayItems(value, { ignoreKeys });\n        }\n        result[camelizeString(key)] = value;\n    }\n    return result;\n}\n\n/**\n * SetTimeout as Promise.\n *\n * @param {number} ms Timeout in milliseconds.\n */\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nfunction getUserAgent$1({ libraryName, libraryVersion, userAgent, publicKey = '', integration = '' }) {\n    const languageName = 'JavaScript';\n    if (typeof userAgent === 'string') {\n        return userAgent;\n    }\n    if (typeof userAgent === 'function') {\n        return userAgent({\n            publicKey,\n            libraryName,\n            libraryVersion,\n            languageName,\n            integration\n        });\n    }\n    const mainInfo = [libraryName, libraryVersion, publicKey]\n        .filter(Boolean)\n        .join('/');\n    const additionInfo = [languageName, integration].filter(Boolean).join('; ');\n    return `${mainInfo} (${additionInfo})`;\n}\n\nconst defaultOptions = {\n    factor: 2,\n    time: 100\n};\nfunction retrier(fn, options = defaultOptions) {\n    let attempts = 0;\n    function runAttempt(fn) {\n        const defaultDelayTime = Math.round(options.time * options.factor ** attempts);\n        const retry = (ms) => delay(ms ?? defaultDelayTime).then(() => {\n            attempts += 1;\n            return runAttempt(fn);\n        });\n        return fn({\n            attempt: attempts,\n            retry\n        });\n    }\n    return runAttempt(fn);\n}\n\nclass UploadcareError extends Error {\n}\n\nclass NetworkError extends UploadcareError {\n    originalProgressEvent;\n    constructor(progressEvent) {\n        super();\n        this.name = 'NetworkError';\n        this.message = 'Network error';\n        Object.setPrototypeOf(this, NetworkError.prototype);\n        this.originalProgressEvent = progressEvent;\n    }\n}\n\nconst onCancel = (signal, callback) => {\n    if (signal) {\n        if (signal.aborted) {\n            Promise.resolve().then(callback);\n        }\n        else {\n            signal.addEventListener('abort', () => callback(), { once: true });\n        }\n    }\n};\n\nclass CancelError extends UploadcareError {\n    isCancel = true;\n    constructor(message = 'Request canceled') {\n        super(message);\n        this.name = 'CancelError';\n        Object.setPrototypeOf(this, CancelError.prototype);\n    }\n}\n\nconst DEFAULT_INTERVAL = 500;\nconst poll = ({ check, interval = DEFAULT_INTERVAL, timeout, signal }) => new Promise((resolve, reject) => {\n    let tickTimeoutId;\n    let timeoutId;\n    onCancel(signal, () => {\n        tickTimeoutId && clearTimeout(tickTimeoutId);\n        reject(new CancelError('Poll cancelled'));\n    });\n    if (timeout) {\n        timeoutId = setTimeout(() => {\n            tickTimeoutId && clearTimeout(tickTimeoutId);\n            reject(new CancelError('Timed out'));\n        }, timeout);\n    }\n    const tick = () => {\n        try {\n            Promise.resolve(check(signal))\n                .then((result) => {\n                if (result) {\n                    timeoutId && clearTimeout(timeoutId);\n                    resolve(result);\n                }\n                else {\n                    tickTimeoutId = setTimeout(tick, interval);\n                }\n            })\n                .catch((error) => {\n                timeoutId && clearTimeout(timeoutId);\n                reject(error);\n            });\n        }\n        catch (error) {\n            timeoutId && clearTimeout(timeoutId);\n            reject(error);\n        }\n    };\n    tickTimeoutId = setTimeout(tick, 0);\n});\n\n/*\n  Settings for future support:\n  parallelDirectUploads: 10,\n */\nconst defaultSettings = {\n    baseCDN: 'https://ucarecdn.com',\n    baseURL: 'https://upload.uploadcare.com',\n    maxContentLength: 50 * 1024 * 1024, // 50 MB\n    retryThrottledRequestMaxTimes: 1,\n    retryNetworkErrorMaxTimes: 3,\n    multipartMinFileSize: 25 * 1024 * 1024, // 25 MB\n    multipartChunkSize: 5 * 1024 * 1024, // 5 MB\n    multipartMinLastPartSize: 1024 * 1024, // 1MB\n    maxConcurrentRequests: 4,\n    pollingTimeoutMilliseconds: 10000,\n    pusherKey: '79ae88bd931ea68464d9'\n};\nconst defaultContentType = 'application/octet-stream';\nconst defaultFilename = 'original';\n\nconst request = ({ method, url, data, headers = {}, signal, onProgress }) => new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    const requestMethod = method?.toUpperCase() || 'GET';\n    let aborted = false;\n    /**\n     * Force synchronous flag to be off Some chrome versions gets\n     * `InvalidAccessError` error when we set `responseType` See\n     * https://xhr.spec.whatwg.org/#synchronous-flag and\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=1346628\n     */\n    xhr.open(requestMethod, url, true);\n    if (headers) {\n        Object.entries(headers).forEach((entry) => {\n            const [key, value] = entry;\n            typeof value !== 'undefined' &&\n                !Array.isArray(value) &&\n                xhr.setRequestHeader(key, value);\n        });\n    }\n    xhr.responseType = 'text';\n    onCancel(signal, () => {\n        aborted = true;\n        xhr.abort();\n        reject(new CancelError());\n    });\n    xhr.onload = () => {\n        if (xhr.status != 200) {\n            // analyze HTTP status of the response\n            reject(new Error(`Error ${xhr.status}: ${xhr.statusText}`)); // e.g. 404: Not Found\n        }\n        else {\n            const request = {\n                method: requestMethod,\n                url,\n                data,\n                headers: headers || undefined,\n                signal,\n                onProgress\n            };\n            // Convert the header string into an array\n            // of individual headers\n            const headersArray = xhr\n                .getAllResponseHeaders()\n                .trim()\n                .split(/[\\r\\n]+/);\n            // Create a map of header names to values\n            const responseHeaders = {};\n            headersArray.forEach(function (line) {\n                const parts = line.split(': ');\n                const header = parts.shift();\n                const value = parts.join(': ');\n                if (header && typeof header !== 'undefined') {\n                    responseHeaders[header] = value;\n                }\n            });\n            const responseData = xhr.response;\n            const responseStatus = xhr.status;\n            resolve({\n                request,\n                data: responseData,\n                headers: responseHeaders,\n                status: responseStatus\n            });\n        }\n    };\n    xhr.onerror = (progressEvent) => {\n        if (aborted)\n            return;\n        // only triggers if the request couldn't be made at all\n        reject(new NetworkError(progressEvent));\n    };\n    if (onProgress && typeof onProgress === 'function') {\n        xhr.upload.onprogress = (event) => {\n            if (event.lengthComputable) {\n                onProgress({\n                    isComputable: true,\n                    value: event.loaded / event.total\n                });\n            }\n            else {\n                onProgress({ isComputable: false });\n            }\n        };\n    }\n    if (data) {\n        xhr.send(data);\n    }\n    else {\n        xhr.send();\n    }\n});\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction identity(obj, ..._args) {\n    return obj;\n}\n\nconst getFileOptions = ({ name }) => name ? [name] : [];\nconst transformFile = identity;\nvar getFormData = () => new FormData();\n\nconst isBuffer = (data) => false;\n\nconst isBlob = (data) => {\n    return typeof Blob !== 'undefined' && data instanceof Blob;\n};\nconst isFile = (data) => {\n    return typeof File !== 'undefined' && data instanceof File;\n};\nconst isReactNativeAsset = (data) => {\n    return (!!data &&\n        typeof data === 'object' &&\n        !Array.isArray(data) &&\n        'uri' in data &&\n        typeof data.uri === 'string');\n};\nconst isFileData = (data) => {\n    return (isBlob(data) || isFile(data) || isBuffer() || isReactNativeAsset(data));\n};\n\nconst isSimpleValue = (value) => {\n    return (typeof value === 'string' ||\n        typeof value === 'number' ||\n        typeof value === 'undefined');\n};\nconst isObjectValue = (value) => {\n    return !!value && typeof value === 'object' && !Array.isArray(value);\n};\nconst isFileValue = (value) => !!value &&\n    typeof value === 'object' &&\n    'data' in value &&\n    isFileData(value.data);\nfunction collectParams(params, inputKey, inputValue) {\n    if (Array.isArray(inputValue)) {\n        for (const value of inputValue) {\n            collectParams(params, `${inputKey}[]`, value);\n        }\n    }\n    else if (isFileValue(inputValue)) {\n        const { name, contentType } = inputValue;\n        const file = transformFile(inputValue.data, name, contentType ?? defaultContentType);\n        const options = getFileOptions({ name, contentType });\n        params.push([inputKey, file, ...options]);\n    }\n    else if (isObjectValue(inputValue)) {\n        for (const [key, value] of Object.entries(inputValue)) {\n            if (typeof value !== 'undefined') {\n                params.push([`${inputKey}[${key}]`, String(value)]);\n            }\n        }\n    }\n    else if (isSimpleValue(inputValue) && inputValue) {\n        params.push([inputKey, inputValue.toString()]);\n    }\n}\nfunction getFormDataParams(options) {\n    const params = [];\n    for (const [key, value] of Object.entries(options)) {\n        collectParams(params, key, value);\n    }\n    return params;\n}\nfunction buildFormData(options) {\n    const formData = getFormData();\n    const paramsList = getFormDataParams(options);\n    for (const params of paramsList) {\n        const [key, value, ...rest] = params;\n        // node form-data has another signature for append\n        formData.append(key, value, ...rest);\n    }\n    return formData;\n}\n\nclass UploadError extends UploadcareError {\n    code;\n    request;\n    response;\n    headers;\n    constructor(message, code, request, response, headers) {\n        super();\n        this.name = 'UploadError';\n        this.message = message;\n        this.code = code;\n        this.request = request;\n        this.response = response;\n        this.headers = headers;\n        Object.setPrototypeOf(this, UploadError.prototype);\n    }\n}\n\nconst buildSearchParams = (query) => {\n    const searchParams = new URLSearchParams();\n    for (const [key, value] of Object.entries(query)) {\n        if (value && typeof value === 'object' && !Array.isArray(value)) {\n            Object.entries(value)\n                .filter((entry) => entry[1] ?? false)\n                .forEach((entry) => searchParams.set(`${key}[${entry[0]}]`, String(entry[1])));\n        }\n        else if (Array.isArray(value)) {\n            value.forEach((val) => {\n                searchParams.append(`${key}[]`, val);\n            });\n        }\n        else if (typeof value === 'string' && value) {\n            searchParams.set(key, value);\n        }\n        else if (typeof value === 'number') {\n            searchParams.set(key, value.toString());\n        }\n    }\n    return searchParams.toString();\n};\nconst getUrl = (base, path, query) => {\n    const url = new URL(base);\n    url.pathname = (url.pathname + path).replace('//', '/');\n    if (query) {\n        url.search = buildSearchParams(query);\n    }\n    return url.toString();\n};\n\nvar version = '6.14.1';\n\nconst LIBRARY_NAME = 'UploadcareUploadClient';\nconst LIBRARY_VERSION = version;\nfunction getUserAgent(options) {\n    return getUserAgent$1({\n        libraryName: LIBRARY_NAME,\n        libraryVersion: LIBRARY_VERSION,\n        ...options\n    });\n}\n\nconst REQUEST_WAS_THROTTLED_CODE = 'RequestThrottledError';\nconst DEFAULT_RETRY_AFTER_TIMEOUT = 15000;\nconst DEFAULT_NETWORK_ERROR_TIMEOUT = 1000;\nfunction getTimeoutFromThrottledRequest(error) {\n    const { headers } = error || {};\n    if (!headers || typeof headers['retry-after'] !== 'string') {\n        return DEFAULT_RETRY_AFTER_TIMEOUT;\n    }\n    const seconds = parseInt(headers['retry-after'], 10);\n    if (!Number.isFinite(seconds)) {\n        return DEFAULT_RETRY_AFTER_TIMEOUT;\n    }\n    return seconds * 1000;\n}\nfunction retryIfFailed(fn, options) {\n    const { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes } = options;\n    return retrier(({ attempt, retry }) => fn().catch((error) => {\n        if ('response' in error &&\n            error?.code === REQUEST_WAS_THROTTLED_CODE &&\n            attempt < retryThrottledRequestMaxTimes) {\n            return retry(getTimeoutFromThrottledRequest(error));\n        }\n        if (error instanceof NetworkError &&\n            attempt < retryNetworkErrorMaxTimes) {\n            return retry((attempt + 1) * DEFAULT_NETWORK_ERROR_TIMEOUT);\n        }\n        throw error;\n    }));\n}\n\nconst getContentType = (file) => {\n    let contentType = '';\n    if (isBlob(file) || isFile(file) || isReactNativeAsset(file)) {\n        contentType = file.type;\n    }\n    return contentType || defaultContentType;\n};\n\nconst getFileName = (file) => {\n    let filename = '';\n    if (isFile(file) && file.name) {\n        filename = file.name;\n    }\n    else if (isBlob(file) || isBuffer()) {\n        filename = '';\n    }\n    else if (isReactNativeAsset(file) && file.name) {\n        filename = file.name;\n    }\n    return filename || defaultFilename;\n};\n\nfunction getStoreValue(store) {\n    if (typeof store === 'undefined' || store === 'auto') {\n        return 'auto';\n    }\n    return store ? '1' : '0';\n}\n\n/**\n * Performs file uploading request to Uploadcare Upload API. Can be canceled and\n * has progress.\n */\nfunction base(file, { publicKey, fileName, contentType, baseURL = defaultSettings.baseURL, secureSignature, secureExpire, store, signal, onProgress, source = 'local', integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes, metadata }) {\n    return retryIfFailed(() => request({\n        method: 'POST',\n        url: getUrl(baseURL, '/base/', {\n            jsonerrors: 1\n        }),\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        data: buildFormData({\n            file: {\n                data: file,\n                name: fileName || getFileName(file),\n                contentType: contentType || getContentType(file)\n            },\n            UPLOADCARE_PUB_KEY: publicKey,\n            UPLOADCARE_STORE: getStoreValue(store),\n            signature: secureSignature,\n            expire: secureExpire,\n            source: source,\n            metadata\n        }),\n        signal,\n        onProgress\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });\n}\n\nvar TypeEnum;\n(function (TypeEnum) {\n    TypeEnum[\"Token\"] = \"token\";\n    TypeEnum[\"FileInfo\"] = \"file_info\";\n})(TypeEnum || (TypeEnum = {}));\n/** Uploading files from URL. */\nfunction fromUrl(sourceUrl, { publicKey, baseURL = defaultSettings.baseURL, store, fileName, checkForUrlDuplicates, saveUrlForRecurrentUploads, secureSignature, secureExpire, source = 'url', signal, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes, metadata }) {\n    return retryIfFailed(() => request({\n        method: 'POST',\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        url: getUrl(baseURL, '/from_url/', {\n            jsonerrors: 1,\n            pub_key: publicKey,\n            source_url: sourceUrl,\n            store: getStoreValue(store),\n            filename: fileName,\n            check_URL_duplicates: checkForUrlDuplicates ? 1 : undefined,\n            save_URL_duplicates: saveUrlForRecurrentUploads ? 1 : undefined,\n            signature: secureSignature,\n            expire: secureExpire,\n            source: source,\n            metadata\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });\n}\n\nvar Status;\n(function (Status) {\n    Status[\"Unknown\"] = \"unknown\";\n    Status[\"Waiting\"] = \"waiting\";\n    Status[\"Progress\"] = \"progress\";\n    Status[\"Error\"] = \"error\";\n    Status[\"Success\"] = \"success\";\n})(Status || (Status = {}));\nconst isErrorResponse = (response) => {\n    return 'status' in response && response.status === Status.Error;\n};\n/** Checking upload status and working with file tokens. */\nfunction fromUrlStatus(token, { publicKey, baseURL = defaultSettings.baseURL, signal, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes } = {}) {\n    return retryIfFailed(() => request({\n        method: 'GET',\n        headers: publicKey\n            ? {\n                'X-UC-User-Agent': getUserAgent({\n                    publicKey,\n                    integration,\n                    userAgent\n                })\n            }\n            : undefined,\n        url: getUrl(baseURL, '/from_url/status/', {\n            jsonerrors: 1,\n            token\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response && !isErrorResponse(response)) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });\n}\n\n/** Create files group. */\nfunction group(uuids, { publicKey, baseURL = defaultSettings.baseURL, jsonpCallback, secureSignature, secureExpire, signal, source, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {\n    return retryIfFailed(() => request({\n        method: 'POST',\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        url: getUrl(baseURL, '/group/', {\n            jsonerrors: 1\n        }),\n        data: buildFormData({\n            files: uuids,\n            callback: jsonpCallback,\n            pub_key: publicKey,\n            signature: secureSignature,\n            expire: secureExpire,\n            source\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryNetworkErrorMaxTimes, retryThrottledRequestMaxTimes });\n}\n\n/** Get info about group. */\nfunction groupInfo(id, { publicKey, baseURL = defaultSettings.baseURL, signal, source, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {\n    return retryIfFailed(() => request({\n        method: 'GET',\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        url: getUrl(baseURL, '/group/info/', {\n            jsonerrors: 1,\n            pub_key: publicKey,\n            group_id: id,\n            source\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });\n}\n\n/** Returns a JSON dictionary holding file info. */\nfunction info(uuid, { publicKey, baseURL = defaultSettings.baseURL, signal, source, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {\n    return retryIfFailed(() => request({\n        method: 'GET',\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        url: getUrl(baseURL, '/info/', {\n            jsonerrors: 1,\n            pub_key: publicKey,\n            file_id: uuid,\n            source\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });\n}\n\n/** Start multipart uploading. */\nfunction multipartStart(size, { publicKey, contentType, fileName, multipartChunkSize = defaultSettings.multipartChunkSize, baseURL = '', secureSignature, secureExpire, store, signal, source = 'local', integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes, metadata }) {\n    return retryIfFailed(() => request({\n        method: 'POST',\n        url: getUrl(baseURL, '/multipart/start/', { jsonerrors: 1 }),\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        data: buildFormData({\n            filename: fileName || defaultFilename,\n            size: size,\n            content_type: contentType || defaultContentType,\n            part_size: multipartChunkSize,\n            UPLOADCARE_STORE: getStoreValue(store),\n            UPLOADCARE_PUB_KEY: publicKey,\n            signature: secureSignature,\n            expire: secureExpire,\n            source: source,\n            metadata\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            // convert to array\n            response.parts = Object.keys(response.parts).map((key) => response.parts[Number(key)]);\n            return response;\n        }\n    }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });\n}\n\n/** Complete multipart uploading. */\nfunction multipartUpload(part, url, { contentType, signal, onProgress, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {\n    return retryIfFailed(() => request({\n        method: 'PUT',\n        url,\n        data: part,\n        // Upload request can't be non-computable because we always know exact size\n        onProgress: onProgress,\n        signal,\n        headers: {\n            'Content-Type': contentType || defaultContentType\n        }\n    })\n        .then((result) => {\n        // hack for node ¯\\_(ツ)_/¯\n        if (onProgress)\n            onProgress({\n                isComputable: true,\n                value: 1\n            });\n        return result;\n    })\n        .then(({ status }) => ({ code: status })), {\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes\n    });\n}\n\n/** Complete multipart uploading. */\nfunction multipartComplete(uuid, { publicKey, baseURL = defaultSettings.baseURL, source = 'local', signal, integration, userAgent, retryThrottledRequestMaxTimes = defaultSettings.retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes = defaultSettings.retryNetworkErrorMaxTimes }) {\n    return retryIfFailed(() => request({\n        method: 'POST',\n        url: getUrl(baseURL, '/multipart/complete/', { jsonerrors: 1 }),\n        headers: {\n            'X-UC-User-Agent': getUserAgent({ publicKey, integration, userAgent })\n        },\n        data: buildFormData({\n            uuid: uuid,\n            UPLOADCARE_PUB_KEY: publicKey,\n            source: source\n        }),\n        signal\n    }).then(({ data, headers, request }) => {\n        const response = camelizeKeys(JSON.parse(data));\n        if ('error' in response) {\n            throw new UploadError(response.error.content, response.error.errorCode, request, response, headers);\n        }\n        else {\n            return response;\n        }\n    }), { retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes });\n}\n\nfunction isReadyPoll(uuid, { publicKey, baseURL, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, signal, onProgress }) {\n    return poll({\n        check: (signal) => info(uuid, {\n            publicKey,\n            baseURL,\n            signal,\n            source,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes\n        }).then((response) => {\n            if (response.isReady) {\n                return response;\n            }\n            onProgress && onProgress({ isComputable: true, value: 1 });\n            return false;\n        }),\n        signal\n    });\n}\n\nfunction isGroupFileInfo(fileInfo) {\n    return 'defaultEffects' in fileInfo;\n}\nclass UploadcareFile {\n    uuid;\n    name = null;\n    size = null;\n    isStored = null;\n    isImage = null;\n    mimeType = null;\n    cdnUrl = null;\n    s3Url = null;\n    originalFilename = null;\n    imageInfo = null;\n    videoInfo = null;\n    contentInfo = null;\n    metadata = null;\n    s3Bucket = null;\n    defaultEffects = null;\n    constructor(fileInfo, { baseCDN = defaultSettings.baseCDN, fileName } = {}) {\n        const { uuid, s3Bucket } = fileInfo;\n        const cdnUrl = getUrl(baseCDN, `${uuid}/`);\n        const s3Url = s3Bucket\n            ? getUrl(`https://${s3Bucket}.s3.amazonaws.com/`, `${uuid}/${fileInfo.filename}`)\n            : null;\n        this.uuid = uuid;\n        this.name = fileName || fileInfo.filename;\n        this.size = fileInfo.size;\n        this.isStored = fileInfo.isStored;\n        this.isImage = fileInfo.isImage;\n        this.mimeType = fileInfo.mimeType;\n        this.cdnUrl = cdnUrl;\n        this.originalFilename = fileInfo.originalFilename;\n        this.imageInfo = fileInfo.imageInfo;\n        this.videoInfo = fileInfo.videoInfo;\n        this.contentInfo = fileInfo.contentInfo;\n        this.metadata = fileInfo.metadata || null;\n        this.s3Bucket = s3Bucket || null;\n        this.s3Url = s3Url;\n        if (isGroupFileInfo(fileInfo)) {\n            this.defaultEffects = fileInfo.defaultEffects;\n        }\n    }\n}\n\nconst uploadDirect = (file, { publicKey, fileName, baseURL, secureSignature, secureExpire, store, contentType, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, baseCDN, metadata }) => {\n    return base(file, {\n        publicKey,\n        fileName,\n        contentType,\n        baseURL,\n        secureSignature,\n        secureExpire,\n        store,\n        signal,\n        onProgress,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes,\n        metadata\n    })\n        .then(({ file }) => {\n        return isReadyPoll(file, {\n            publicKey,\n            baseURL,\n            source,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes,\n            onProgress,\n            signal\n        });\n    })\n        .then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));\n};\n\nconst uploadFromUploaded = (uuid, { publicKey, fileName, baseURL, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, baseCDN }) => {\n    return info(uuid, {\n        publicKey,\n        baseURL,\n        signal,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes\n    })\n        .then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN, fileName }))\n        .then((result) => {\n        // hack for node ¯\\_(ツ)_/¯\n        if (onProgress)\n            onProgress({\n                isComputable: true,\n                value: 1\n            });\n        return result;\n    });\n};\n\nconst race = (fns, { signal } = {}) => {\n    let lastError = null;\n    let winnerIndex = null;\n    const controllers = fns.map(() => new AbortController());\n    const createStopRaceCallback = (i) => () => {\n        winnerIndex = i;\n        controllers.forEach((controller, index) => index !== i && controller.abort());\n    };\n    onCancel(signal, () => {\n        controllers.forEach((controller) => controller.abort());\n    });\n    return Promise.all(fns.map((fn, i) => {\n        const stopRace = createStopRaceCallback(i);\n        return Promise.resolve()\n            .then(() => fn({ stopRace, signal: controllers[i].signal }))\n            .then((result) => {\n            stopRace();\n            return result;\n        })\n            .catch((error) => {\n            lastError = error;\n            return null;\n        });\n    })).then((results) => {\n        if (winnerIndex === null) {\n            throw lastError;\n        }\n        else {\n            return results[winnerIndex];\n        }\n    });\n};\n\nvar WebSocket = window.WebSocket;\n\nclass Events {\n    events = Object.create({});\n    emit(event, data) {\n        this.events[event]?.forEach((fn) => fn(data));\n    }\n    on(event, callback) {\n        this.events[event] = this.events[event] || [];\n        this.events[event].push(callback);\n    }\n    off(event, callback) {\n        if (callback) {\n            this.events[event] = this.events[event].filter((fn) => fn !== callback);\n        }\n        else {\n            this.events[event] = [];\n        }\n    }\n}\n\nconst response = (type, data) => {\n    if (type === 'success') {\n        return { status: Status.Success, ...data };\n    }\n    if (type === 'progress') {\n        return { status: Status.Progress, ...data };\n    }\n    return { status: Status.Error, ...data };\n};\nclass Pusher {\n    key;\n    disconnectTime;\n    ws = undefined;\n    queue = [];\n    isConnected = false;\n    subscribers = 0;\n    emmitter = new Events();\n    disconnectTimeoutId = null;\n    constructor(pusherKey, disconnectTime = 30000) {\n        this.key = pusherKey;\n        this.disconnectTime = disconnectTime;\n    }\n    connect() {\n        this.disconnectTimeoutId && clearTimeout(this.disconnectTimeoutId);\n        if (!this.isConnected && !this.ws) {\n            const pusherUrl = `wss://ws.pusherapp.com/app/${this.key}?protocol=5&client=js&version=1.12.2`;\n            this.ws = new WebSocket(pusherUrl);\n            this.ws.addEventListener('error', (error) => {\n                this.emmitter.emit('error', new Error(error.message));\n            });\n            this.emmitter.on('connected', () => {\n                this.isConnected = true;\n                this.queue.forEach((message) => this.send(message.event, message.data));\n                this.queue = [];\n            });\n            this.ws.addEventListener('message', (e) => {\n                const data = JSON.parse(e.data.toString());\n                switch (data.event) {\n                    case 'pusher:connection_established': {\n                        this.emmitter.emit('connected', undefined);\n                        break;\n                    }\n                    case 'pusher:ping': {\n                        this.send('pusher:pong', {});\n                        break;\n                    }\n                    case 'progress':\n                    case 'success':\n                    case 'fail': {\n                        this.emmitter.emit(data.channel, response(data.event, JSON.parse(data.data)));\n                    }\n                }\n            });\n        }\n    }\n    disconnect() {\n        const actualDisconect = () => {\n            this.ws?.close();\n            this.ws = undefined;\n            this.isConnected = false;\n        };\n        if (this.disconnectTime) {\n            this.disconnectTimeoutId = setTimeout(() => {\n                actualDisconect();\n            }, this.disconnectTime);\n        }\n        else {\n            actualDisconect();\n        }\n    }\n    send(event, data) {\n        const str = JSON.stringify({ event, data });\n        this.ws?.send(str);\n    }\n    subscribe(token, handler) {\n        this.subscribers += 1;\n        this.connect();\n        const channel = `task-status-${token}`;\n        const message = {\n            event: 'pusher:subscribe',\n            data: { channel }\n        };\n        this.emmitter.on(channel, handler);\n        if (this.isConnected) {\n            this.send(message.event, message.data);\n        }\n        else {\n            this.queue.push(message);\n        }\n    }\n    unsubscribe(token) {\n        this.subscribers -= 1;\n        const channel = `task-status-${token}`;\n        const message = {\n            event: 'pusher:unsubscribe',\n            data: { channel }\n        };\n        this.emmitter.off(channel);\n        if (this.isConnected) {\n            this.send(message.event, message.data);\n        }\n        else {\n            this.queue = this.queue.filter((msg) => msg.data.channel !== channel);\n        }\n        if (this.subscribers === 0) {\n            this.disconnect();\n        }\n    }\n    onError(callback) {\n        this.emmitter.on('error', callback);\n        return () => this.emmitter.off('error', callback);\n    }\n}\nlet pusher = null;\nconst getPusher = (key) => {\n    if (!pusher) {\n        // no timeout for nodeJS and 30000 ms for browser\n        const disconectTimeout = typeof window === 'undefined' ? 0 : 30000;\n        pusher = new Pusher(key, disconectTimeout);\n    }\n    return pusher;\n};\nconst preconnect = (key) => {\n    getPusher(key).connect();\n};\n\nfunction pollStrategy({ token, publicKey, baseURL, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, onProgress, signal }) {\n    return poll({\n        check: (signal) => fromUrlStatus(token, {\n            publicKey,\n            baseURL,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes,\n            signal\n        }).then((response) => {\n            switch (response.status) {\n                case Status.Error: {\n                    return new UploadError(response.error, response.errorCode);\n                }\n                case Status.Waiting: {\n                    return false;\n                }\n                case Status.Unknown: {\n                    return new UploadError(`Token \"${token}\" was not found.`);\n                }\n                case Status.Progress: {\n                    if (onProgress) {\n                        if (response.total === 'unknown') {\n                            onProgress({ isComputable: false });\n                        }\n                        else {\n                            onProgress({\n                                isComputable: true,\n                                value: response.done / response.total\n                            });\n                        }\n                    }\n                    return false;\n                }\n                case Status.Success: {\n                    if (onProgress)\n                        onProgress({\n                            isComputable: true,\n                            value: response.done / response.total\n                        });\n                    return response;\n                }\n                default: {\n                    throw new Error('Unknown status');\n                }\n            }\n        }),\n        signal\n    });\n}\nconst pushStrategy = ({ token, pusherKey, signal, onProgress }) => new Promise((resolve, reject) => {\n    const pusher = getPusher(pusherKey);\n    const unsubErrorHandler = pusher.onError(reject);\n    const destroy = () => {\n        unsubErrorHandler();\n        pusher.unsubscribe(token);\n    };\n    onCancel(signal, () => {\n        destroy();\n        reject(new CancelError('pusher cancelled'));\n    });\n    pusher.subscribe(token, (result) => {\n        switch (result.status) {\n            case Status.Progress: {\n                if (onProgress) {\n                    if (result.total === 'unknown') {\n                        onProgress({ isComputable: false });\n                    }\n                    else {\n                        onProgress({\n                            isComputable: true,\n                            value: result.done / result.total\n                        });\n                    }\n                }\n                break;\n            }\n            case Status.Success: {\n                destroy();\n                if (onProgress)\n                    onProgress({\n                        isComputable: true,\n                        value: result.done / result.total\n                    });\n                resolve(result);\n                break;\n            }\n            case Status.Error: {\n                destroy();\n                reject(new UploadError(result.msg, result.error_code));\n            }\n        }\n    });\n});\nconst uploadFromUrl = (sourceUrl, { publicKey, fileName, baseURL, baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, pusherKey = defaultSettings.pusherKey, metadata }) => Promise.resolve(preconnect(pusherKey))\n    .then(() => fromUrl(sourceUrl, {\n    publicKey,\n    fileName,\n    baseURL,\n    checkForUrlDuplicates,\n    saveUrlForRecurrentUploads,\n    secureSignature,\n    secureExpire,\n    store,\n    signal,\n    source,\n    integration,\n    userAgent,\n    retryThrottledRequestMaxTimes,\n    metadata\n}))\n    .catch((error) => {\n    const pusher = getPusher(pusherKey);\n    pusher?.disconnect();\n    return Promise.reject(error);\n})\n    .then((urlResponse) => {\n    if (urlResponse.type === TypeEnum.FileInfo) {\n        return urlResponse;\n    }\n    else {\n        return race([\n            ({ signal }) => pollStrategy({\n                token: urlResponse.token,\n                publicKey,\n                baseURL,\n                integration,\n                userAgent,\n                retryThrottledRequestMaxTimes,\n                onProgress,\n                signal\n            }),\n            ({ signal }) => pushStrategy({\n                token: urlResponse.token,\n                pusherKey,\n                signal,\n                onProgress\n            })\n        ], { signal });\n    }\n})\n    .then((result) => {\n    if (result instanceof UploadError)\n        throw result;\n    return result;\n})\n    .then((result) => isReadyPoll(result.uuid, {\n    publicKey,\n    baseURL,\n    integration,\n    userAgent,\n    retryThrottledRequestMaxTimes,\n    onProgress,\n    signal\n}))\n    .then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));\n\nconst memo = new WeakMap();\nconst getBlobFromReactNativeAsset = async (asset) => {\n    if (memo.has(asset)) {\n        return memo.get(asset);\n    }\n    const blob = await fetch(asset.uri).then((res) => res.blob());\n    memo.set(asset, blob);\n    return blob;\n};\n\nconst getFileSize = async (file) => {\n    if (isFile(file) || isBlob(file)) {\n        return file.size;\n    }\n    if (isReactNativeAsset(file)) {\n        const blob = await getBlobFromReactNativeAsset(file);\n        return blob.size;\n    }\n    throw new Error(`Unknown file type. Cannot determine file size.`);\n};\n\n/** Check if FileData is multipart data. */\nconst isMultipart = (fileSize, multipartMinFileSize = defaultSettings.multipartMinFileSize) => {\n    return fileSize >= multipartMinFileSize;\n};\n\n/** Uuid type guard. */\nconst isUuid = (data) => {\n    const UUID_REGEX = '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}';\n    const regExp = new RegExp(UUID_REGEX);\n    return !isFileData(data) && regExp.test(data);\n};\n/**\n * Url type guard.\n *\n * @param {SupportedFileInput | Url | Uuid} data\n */\nconst isUrl = (data) => {\n    const URL_REGEX = '^(?:\\\\w+:)?\\\\/\\\\/([^\\\\s\\\\.]+\\\\.\\\\S{2}|localhost[\\\\:?\\\\d]*)\\\\S*$';\n    const regExp = new RegExp(URL_REGEX);\n    return !isFileData(data) && regExp.test(data);\n};\n\nconst runWithConcurrency = (concurrency, tasks) => {\n    return new Promise((resolve, reject) => {\n        const results = [];\n        let rejected = false;\n        let settled = tasks.length;\n        const forRun = [...tasks];\n        const run = () => {\n            const index = tasks.length - forRun.length;\n            const next = forRun.shift();\n            if (next) {\n                next()\n                    .then((result) => {\n                    if (rejected)\n                        return;\n                    results[index] = result;\n                    settled -= 1;\n                    if (settled) {\n                        run();\n                    }\n                    else {\n                        resolve(results);\n                    }\n                })\n                    .catch((error) => {\n                    rejected = true;\n                    reject(error);\n                });\n            }\n        };\n        for (let i = 0; i < concurrency; i++) {\n            run();\n        }\n    });\n};\n\nconst sliceChunk = (file, index, fileSize, chunkSize) => {\n    const start = chunkSize * index;\n    const end = Math.min(start + chunkSize, fileSize);\n    return file.slice(start, end);\n};\n\nconst prepareChunks = async (file, fileSize, chunkSize) => {\n    return (index) => sliceChunk(file, index, fileSize, chunkSize);\n};\n\nconst uploadPart = (chunk, url, { publicKey, contentType, onProgress, signal, integration, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes }) => multipartUpload(chunk, url, {\n    publicKey,\n    contentType,\n    onProgress,\n    signal,\n    integration,\n    retryThrottledRequestMaxTimes,\n    retryNetworkErrorMaxTimes\n});\nconst uploadMultipart = async (file, { publicKey, fileName, fileSize, baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartChunkSize = defaultSettings.multipartChunkSize, maxConcurrentRequests = defaultSettings.maxConcurrentRequests, baseCDN, metadata }) => {\n    const size = fileSize ?? (await getFileSize(file));\n    let progressValues;\n    const createProgressHandler = (totalChunks, chunkIdx) => {\n        if (!onProgress)\n            return;\n        if (!progressValues) {\n            progressValues = Array(totalChunks).fill(0);\n        }\n        const sum = (values) => values.reduce((sum, next) => sum + next, 0);\n        return (info) => {\n            if (!info.isComputable) {\n                return;\n            }\n            progressValues[chunkIdx] = info.value;\n            onProgress({\n                isComputable: true,\n                value: sum(progressValues) / totalChunks\n            });\n        };\n    };\n    contentType ||= getContentType(file);\n    return multipartStart(size, {\n        publicKey,\n        contentType,\n        fileName: fileName || getFileName(file),\n        baseURL,\n        secureSignature,\n        secureExpire,\n        store,\n        signal,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes,\n        metadata\n    })\n        .then(async ({ uuid, parts }) => {\n        const getChunk = await prepareChunks(file, size, multipartChunkSize);\n        return Promise.all([\n            uuid,\n            runWithConcurrency(maxConcurrentRequests, parts.map((url, index) => () => uploadPart(getChunk(index), url, {\n                publicKey,\n                contentType,\n                onProgress: createProgressHandler(parts.length, index),\n                signal,\n                integration,\n                retryThrottledRequestMaxTimes,\n                retryNetworkErrorMaxTimes\n            })))\n        ]);\n    })\n        .then(([uuid]) => multipartComplete(uuid, {\n        publicKey,\n        baseURL,\n        source,\n        integration,\n        userAgent,\n        retryThrottledRequestMaxTimes,\n        retryNetworkErrorMaxTimes\n    }))\n        .then((fileInfo) => {\n        if (fileInfo.isReady) {\n            return fileInfo;\n        }\n        else {\n            return isReadyPoll(fileInfo.uuid, {\n                publicKey,\n                baseURL,\n                source,\n                integration,\n                userAgent,\n                retryThrottledRequestMaxTimes,\n                retryNetworkErrorMaxTimes,\n                onProgress,\n                signal\n            });\n        }\n    })\n        .then((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));\n};\n\n/** Uploads file from provided data. */\nasync function uploadFile(data, { publicKey, fileName, baseURL = defaultSettings.baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartMinFileSize, multipartChunkSize, maxConcurrentRequests, baseCDN = defaultSettings.baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, pusherKey, metadata }) {\n    if (isFileData(data)) {\n        const fileSize = await getFileSize(data);\n        if (isMultipart(fileSize, multipartMinFileSize)) {\n            return uploadMultipart(data, {\n                publicKey,\n                contentType,\n                multipartChunkSize,\n                fileSize,\n                fileName,\n                baseURL,\n                secureSignature,\n                secureExpire,\n                store,\n                signal,\n                onProgress,\n                source,\n                integration,\n                userAgent,\n                maxConcurrentRequests,\n                retryThrottledRequestMaxTimes,\n                retryNetworkErrorMaxTimes,\n                baseCDN,\n                metadata\n            });\n        }\n        return uploadDirect(data, {\n            publicKey,\n            fileName,\n            contentType,\n            baseURL,\n            secureSignature,\n            secureExpire,\n            store,\n            signal,\n            onProgress,\n            source,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes,\n            baseCDN,\n            metadata\n        });\n    }\n    if (isUrl(data)) {\n        return uploadFromUrl(data, {\n            publicKey,\n            fileName,\n            baseURL,\n            baseCDN,\n            checkForUrlDuplicates,\n            saveUrlForRecurrentUploads,\n            secureSignature,\n            secureExpire,\n            store,\n            signal,\n            onProgress,\n            source,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes,\n            pusherKey,\n            metadata\n        });\n    }\n    if (isUuid(data)) {\n        return uploadFromUploaded(data, {\n            publicKey,\n            fileName,\n            baseURL,\n            signal,\n            onProgress,\n            source,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes,\n            baseCDN\n        });\n    }\n    throw new TypeError(`File uploading from \"${data}\" is not supported`);\n}\n\nclass UploadcareGroup {\n    uuid;\n    filesCount;\n    totalSize;\n    isStored;\n    isImage;\n    cdnUrl;\n    files;\n    createdAt;\n    storedAt = null;\n    constructor(groupInfo, { baseCDN = defaultSettings.baseCDN } = {}) {\n        this.uuid = groupInfo.id;\n        this.filesCount = groupInfo.filesCount;\n        const groupFiles = groupInfo.files.filter(Boolean);\n        this.totalSize = Object.values(groupFiles).reduce((acc, file) => acc + file.size, 0);\n        this.isStored = !!groupInfo.datetimeStored;\n        this.isImage = !!Object.values(groupFiles).filter((file) => file.isImage)\n            .length;\n        this.cdnUrl = groupInfo.cdnUrl;\n        this.files = groupFiles.map((fileInfo) => new UploadcareFile(fileInfo, { baseCDN }));\n        this.createdAt = groupInfo.datetimeCreated;\n        this.storedAt = groupInfo.datetimeStored;\n    }\n}\n\n/** FileData type guard. */\nconst isFileDataArray = (data) => {\n    for (const item of data) {\n        if (!isFileData(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/** Uuid type guard. */\nconst isUuidArray = (data) => {\n    for (const item of data) {\n        if (!isUuid(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/** Url type guard. */\nconst isUrlArray = (data) => {\n    for (const item of data) {\n        if (!isUrl(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n\nfunction uploadFileGroup(data, { publicKey, fileName, baseURL = defaultSettings.baseURL, secureSignature, secureExpire, store, signal, onProgress, source, integration, userAgent, retryThrottledRequestMaxTimes, retryNetworkErrorMaxTimes, contentType, multipartChunkSize = defaultSettings.multipartChunkSize, baseCDN = defaultSettings.baseCDN, checkForUrlDuplicates, saveUrlForRecurrentUploads, jsonpCallback }) {\n    if (!isFileDataArray(data) && !isUrlArray(data) && !isUuidArray(data)) {\n        throw new TypeError(`Group uploading from \"${data}\" is not supported`);\n    }\n    let progressValues;\n    let isStillComputable = true;\n    const filesCount = data.length;\n    const createProgressHandler = (size, index) => {\n        if (!onProgress)\n            return;\n        if (!progressValues) {\n            progressValues = Array(size).fill(0);\n        }\n        const normalize = (values) => values.reduce((sum, next) => sum + next) / size;\n        return (info) => {\n            if (!info.isComputable || !isStillComputable) {\n                isStillComputable = false;\n                onProgress({ isComputable: false });\n                return;\n            }\n            progressValues[index] = info.value;\n            onProgress({ isComputable: true, value: normalize(progressValues) });\n        };\n    };\n    return Promise.all(data.map((file, index) => {\n        if (isFileData(file) || isUrl(file)) {\n            return uploadFile(file, {\n                publicKey,\n                fileName,\n                baseURL,\n                secureSignature,\n                secureExpire,\n                store,\n                signal,\n                onProgress: createProgressHandler(filesCount, index),\n                source,\n                integration,\n                userAgent,\n                retryThrottledRequestMaxTimes,\n                retryNetworkErrorMaxTimes,\n                contentType,\n                multipartChunkSize,\n                baseCDN,\n                checkForUrlDuplicates,\n                saveUrlForRecurrentUploads\n            }).then((fileInfo) => fileInfo.uuid);\n        }\n        else {\n            // Do not request file info by uuid before creating group because this isn't necessary\n            return file;\n        }\n    })).then((uuids) => {\n        return group(uuids, {\n            publicKey,\n            baseURL,\n            jsonpCallback,\n            secureSignature,\n            secureExpire,\n            signal,\n            source,\n            integration,\n            userAgent,\n            retryThrottledRequestMaxTimes,\n            retryNetworkErrorMaxTimes\n        })\n            .then((groupInfo) => new UploadcareGroup(groupInfo, { baseCDN }))\n            .then((group) => {\n            onProgress && onProgress({ isComputable: true, value: 1 });\n            return group;\n        });\n    });\n}\n\n/** Populate options with settings. */\nconst populateOptionsWithSettings = (options, settings) => ({\n    ...settings,\n    ...options\n});\nclass UploadClient {\n    settings;\n    constructor(settings) {\n        this.settings = Object.assign({}, defaultSettings, settings);\n    }\n    updateSettings(newSettings) {\n        this.settings = Object.assign(this.settings, newSettings);\n    }\n    getSettings() {\n        return this.settings;\n    }\n    base(file, options = {}) {\n        const settings = this.getSettings();\n        return base(file, populateOptionsWithSettings(options, settings));\n    }\n    info(uuid, options = {}) {\n        const settings = this.getSettings();\n        return info(uuid, populateOptionsWithSettings(options, settings));\n    }\n    fromUrl(sourceUrl, options = {}) {\n        const settings = this.getSettings();\n        return fromUrl(sourceUrl, populateOptionsWithSettings(options, settings));\n    }\n    fromUrlStatus(token, options = {}) {\n        const settings = this.getSettings();\n        return fromUrlStatus(token, populateOptionsWithSettings(options, settings));\n    }\n    group(uuids, options = {}) {\n        const settings = this.getSettings();\n        return group(uuids, populateOptionsWithSettings(options, settings));\n    }\n    groupInfo(id, options = {}) {\n        const settings = this.getSettings();\n        return groupInfo(id, populateOptionsWithSettings(options, settings));\n    }\n    multipartStart(size, options = {}) {\n        const settings = this.getSettings();\n        return multipartStart(size, populateOptionsWithSettings(options, settings));\n    }\n    multipartUpload(part, url, options = {}) {\n        const settings = this.getSettings();\n        return multipartUpload(part, url, populateOptionsWithSettings(options, settings));\n    }\n    multipartComplete(uuid, options = {}) {\n        const settings = this.getSettings();\n        return multipartComplete(uuid, populateOptionsWithSettings(options, settings));\n    }\n    uploadFile(data, options = {}) {\n        const settings = this.getSettings();\n        return uploadFile(data, populateOptionsWithSettings(options, settings));\n    }\n    uploadFileGroup(data, options = {}) {\n        const settings = this.getSettings();\n        return uploadFileGroup(data, populateOptionsWithSettings(options, settings));\n    }\n    isReadyPoll(uuid, options = {}) {\n        const settings = this.getSettings();\n        return isReadyPoll(uuid, populateOptionsWithSettings(options, settings));\n    }\n}\n\nclass Queue {\n    _concurrency = 1;\n    _pending = [];\n    _running = 0;\n    _resolvers = new Map();\n    _rejectors = new Map();\n    constructor(concurrency) {\n        this._concurrency = concurrency;\n    }\n    _run() {\n        const tasksLeft = this._concurrency - this._running;\n        for (let i = 0; i < tasksLeft; i++) {\n            const task = this._pending.shift();\n            if (!task) {\n                return;\n            }\n            const resolver = this._resolvers.get(task);\n            const rejector = this._rejectors.get(task);\n            if (!resolver || !rejector)\n                throw new Error('Unexpected behavior: resolver or rejector is undefined');\n            this._running += 1;\n            task()\n                .finally(() => {\n                this._resolvers.delete(task);\n                this._rejectors.delete(task);\n                this._running -= 1;\n                this._run();\n            })\n                .then((value) => resolver(value))\n                .catch((error) => rejector(error));\n        }\n    }\n    add(task) {\n        return new Promise((resolve, reject) => {\n            this._resolvers.set(task, resolve);\n            this._rejectors.set(task, reject);\n            this._pending.push(task);\n            this._run();\n        });\n    }\n    get pending() {\n        return this._pending.length;\n    }\n    get running() {\n        return this._running;\n    }\n    set concurrency(value) {\n        this._concurrency = value;\n        this._run();\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n}\n\n/* Low-Level API */\n/** @deprecated Please use NetworkError instead. */\nconst UploadcareNetworkError = NetworkError;\n/** @deprecated Please use UploadError instead. */\nconst UploadClientError = UploadError;\n\nexport { CancelError, NetworkError, Queue, UploadClient, UploadClientError, UploadError, UploadcareError, UploadcareFile, UploadcareGroup, UploadcareNetworkError, base, fromUrl, fromUrlStatus, getUserAgent$1 as getUserAgent, group, groupInfo, info, isReadyPoll, multipartComplete, multipartStart, multipartUpload, uploadDirect, uploadFile, uploadFileGroup, uploadFromUploaded, uploadFromUrl, uploadMultipart };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}