{"ast":null,"code":"/**\n * @param {File} file\n * @returns {Promise<boolean>}\n */\nfunction checkIsDirectory(file) {\n  return new Promise(resolve => {\n    if (typeof window.FileReader !== 'function') {\n      resolve(false);\n    }\n    try {\n      let reader = new FileReader();\n      reader.onerror = () => {\n        resolve(true);\n      };\n      let onLoad = e => {\n        if (e.type !== 'loadend') {\n          reader.abort();\n        }\n        resolve(false);\n      };\n      reader.onloadend = onLoad;\n      reader.onprogress = onLoad;\n      reader.readAsDataURL(file);\n    } catch (err) {\n      resolve(false);\n    }\n  });\n}\nfunction readEntryContentAsync(webkitEntry, dataTransferItemType) {\n  return new Promise(resolve => {\n    let reading = 0;\n    let contents = [];\n    let readEntry = entry => {\n      if (!entry) {\n        console.warn('Unexpectedly received empty content entry', {\n          scope: 'drag-and-drop'\n        });\n        resolve(null);\n      }\n      if (entry.isFile) {\n        reading++;\n        entry.file(file => {\n          reading--;\n          // webkitGetAsEntry don't provide type for HEIC images at least, so we use type value from dataTransferItem\n          const clonedFile = new File([file], file.name, {\n            type: file.type || dataTransferItemType\n          });\n          contents.push(clonedFile);\n          if (reading === 0) {\n            resolve(contents);\n          }\n        });\n      } else if (entry.isDirectory) {\n        readReaderContent(entry.createReader());\n      }\n    };\n    let readReaderContent = reader => {\n      reading++;\n      reader.readEntries(entries => {\n        reading--;\n        for (let entry of entries) {\n          readEntry(entry);\n        }\n        if (reading === 0) {\n          resolve(contents);\n        }\n      });\n    };\n    readEntry(webkitEntry);\n  });\n}\n\n/**\n * Note: dataTransfer will be destroyed outside of the call stack. So, do not try to process it asynchronous.\n *\n * @param {DataTransfer} dataTransfer\n * @returns {Promise<(File | String)[]>}\n */\nexport function getDropItems(dataTransfer) {\n  let files = [];\n  let promises = [];\n  for (let i = 0; i < dataTransfer.items.length; i++) {\n    let item = dataTransfer.items[i];\n    if (!item) {\n      continue;\n    }\n    if (item.kind === 'file') {\n      const itemType = item.type;\n      if (typeof item.webkitGetAsEntry === 'function' || typeof ( /** @type {any} */item.getAsEntry) === 'function') {\n        let entry = typeof item.webkitGetAsEntry === 'function' ? item.webkitGetAsEntry() : /** @type {any} */item.getAsEntry();\n        promises.push(readEntryContentAsync(entry, itemType).then(entryContent => {\n          files.push(...entryContent);\n        }));\n        continue;\n      }\n      let file = item.getAsFile();\n      promises.push(checkIsDirectory(file).then(isDirectory => {\n        if (isDirectory) {\n          // we can't get directory files, so we'll skip it\n        } else {\n          files.push(file);\n        }\n      }));\n    } else if (item.kind === 'string' && item.type.match('^text/uri-list')) {\n      promises.push(new Promise(resolve => {\n        item.getAsString(value => {\n          files.push(value);\n          resolve();\n        });\n      }));\n    }\n  }\n  return Promise.all(promises).then(() => files);\n}","map":{"version":3,"names":["checkIsDirectory","file","Promise","resolve","window","FileReader","reader","onerror","onLoad","e","type","abort","onloadend","onprogress","readAsDataURL","err","readEntryContentAsync","webkitEntry","dataTransferItemType","reading","contents","readEntry","entry","console","warn","scope","isFile","clonedFile","File","name","push","isDirectory","readReaderContent","createReader","readEntries","entries","getDropItems","dataTransfer","files","promises","i","items","length","item","kind","itemType","webkitGetAsEntry","getAsEntry","then","entryContent","getAsFile","match","getAsString","value","all"],"sources":["/Users/David/Documents/own_projects/mp4-to-gif/node_modules/@uploadcare/blocks/blocks/DropArea/getDropItems.js"],"sourcesContent":["/**\n * @param {File} file\n * @returns {Promise<boolean>}\n */\nfunction checkIsDirectory(file) {\n  return new Promise((resolve) => {\n    if (typeof window.FileReader !== 'function') {\n      resolve(false);\n    }\n\n    try {\n      let reader = new FileReader();\n      reader.onerror = () => {\n        resolve(true);\n      };\n      let onLoad = (e) => {\n        if (e.type !== 'loadend') {\n          reader.abort();\n        }\n        resolve(false);\n      };\n      reader.onloadend = onLoad;\n      reader.onprogress = onLoad;\n\n      reader.readAsDataURL(file);\n    } catch (err) {\n      resolve(false);\n    }\n  });\n}\n\nfunction readEntryContentAsync(webkitEntry, dataTransferItemType) {\n  return new Promise((resolve) => {\n    let reading = 0;\n    let contents = [];\n\n    let readEntry = (entry) => {\n      if (!entry) {\n        console.warn('Unexpectedly received empty content entry', { scope: 'drag-and-drop' });\n        resolve(null);\n      }\n      if (entry.isFile) {\n        reading++;\n        entry.file((file) => {\n          reading--;\n          // webkitGetAsEntry don't provide type for HEIC images at least, so we use type value from dataTransferItem\n          const clonedFile = new File([file], file.name, { type: file.type || dataTransferItemType });\n          contents.push(clonedFile);\n\n          if (reading === 0) {\n            resolve(contents);\n          }\n        });\n      } else if (entry.isDirectory) {\n        readReaderContent(entry.createReader());\n      }\n    };\n\n    let readReaderContent = (reader) => {\n      reading++;\n\n      reader.readEntries((entries) => {\n        reading--;\n        for (let entry of entries) {\n          readEntry(entry);\n        }\n\n        if (reading === 0) {\n          resolve(contents);\n        }\n      });\n    };\n\n    readEntry(webkitEntry);\n  });\n}\n\n/**\n * Note: dataTransfer will be destroyed outside of the call stack. So, do not try to process it asynchronous.\n *\n * @param {DataTransfer} dataTransfer\n * @returns {Promise<(File | String)[]>}\n */\nexport function getDropItems(dataTransfer) {\n  let files = [];\n  let promises = [];\n  for (let i = 0; i < dataTransfer.items.length; i++) {\n    let item = dataTransfer.items[i];\n    if (!item) {\n      continue;\n    }\n    if (item.kind === 'file') {\n      const itemType = item.type;\n      if (typeof item.webkitGetAsEntry === 'function' || typeof (/** @type {any} */ (item).getAsEntry) === 'function') {\n        let entry =\n          typeof item.webkitGetAsEntry === 'function'\n            ? item.webkitGetAsEntry()\n            : /** @type {any} */ (item).getAsEntry();\n        promises.push(\n          readEntryContentAsync(entry, itemType).then((entryContent) => {\n            files.push(...entryContent);\n          })\n        );\n        continue;\n      }\n\n      let file = item.getAsFile();\n      promises.push(\n        checkIsDirectory(file).then((isDirectory) => {\n          if (isDirectory) {\n            // we can't get directory files, so we'll skip it\n          } else {\n            files.push(file);\n          }\n        })\n      );\n    } else if (item.kind === 'string' && item.type.match('^text/uri-list')) {\n      promises.push(\n        new Promise((resolve) => {\n          item.getAsString((value) => {\n            files.push(value);\n            resolve();\n          });\n        })\n      );\n    }\n  }\n\n  return Promise.all(promises).then(() => files);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}