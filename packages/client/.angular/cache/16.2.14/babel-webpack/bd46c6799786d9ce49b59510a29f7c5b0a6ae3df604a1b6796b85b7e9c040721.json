{"ast":null,"code":"/**\n * Trim leading `-/`, `/` and trailing `/` from CDN operation\n *\n * @param {String | unknown} [operation]\n * @returns {String}\n */\nexport const normalizeCdnOperation = operation => {\n  if (typeof operation !== 'string' || !operation) {\n    return '';\n  }\n  let str = operation.trim();\n  if (str.startsWith('-/')) {\n    str = str.slice(2);\n  } else if (str.startsWith('/')) {\n    str = str.slice(1);\n  }\n  if (str.endsWith('/')) {\n    str = str.slice(0, str.length - 1);\n  }\n  return str;\n};\n\n/**\n * Join multiple CDN operations into one string without trailing or leading delimeters\n *\n * @param {...(String | unknown)} [operations]\n * @returns {String}\n */\nexport const joinCdnOperations = (...operations) => {\n  return operations.filter(op => typeof op === 'string' && op).map(op => normalizeCdnOperation( /** @type {String} */op)).join('/-/');\n};\n\n/**\n * Create string with leading `-/` from passed CDN operations. Do the same as `joinCdnOperations` but adds leading `-/`\n * and trailing `/`\n *\n * @param {...(String | unknown)} [cdnOperations] -\n * @returns {String}\n */\nexport const createCdnUrlModifiers = (...cdnOperations) => {\n  let joined = joinCdnOperations(...cdnOperations);\n  return joined ? `-/${joined}/` : '';\n};\n\n/**\n * Extract filename or file URL\n *\n * @param {String} cdnUrl\n * @returns {String}\n */\nexport function extractFilename(cdnUrl) {\n  let url = new URL(cdnUrl);\n  let noOrigin = url.pathname + url.search + url.hash;\n  let urlFilenameIdx = noOrigin.lastIndexOf('http');\n  let plainFilenameIdx = noOrigin.lastIndexOf('/');\n  let filename = '';\n  if (urlFilenameIdx >= 0) {\n    filename = noOrigin.slice(urlFilenameIdx);\n  } else if (plainFilenameIdx >= 0) {\n    filename = noOrigin.slice(plainFilenameIdx + 1);\n  }\n  return filename;\n}\n\n/**\n * Extract UUID from CDN URL\n *\n * @param {string} cdnUrl\n * @returns {string}\n */\nexport function extractUuid(cdnUrl) {\n  let url = new URL(cdnUrl);\n  let {\n    pathname\n  } = url;\n  const slashIndex = pathname.indexOf('/');\n  const secondSlashIndex = pathname.indexOf('/', slashIndex + 1);\n  return pathname.substring(slashIndex + 1, secondSlashIndex);\n}\n\n/**\n * Extract UUID from CDN URL\n *\n * @param {string} cdnUrl\n * @returns {string[]}\n */\nexport function extractOperations(cdnUrl) {\n  let withoutFilename = trimFilename(cdnUrl);\n  let url = new URL(withoutFilename);\n  let operationsMarker = url.pathname.indexOf('/-/');\n  if (operationsMarker === -1) {\n    return [];\n  }\n  let operationsStr = url.pathname.substring(operationsMarker);\n  return operationsStr.split('/-/').filter(Boolean).map(operation => normalizeCdnOperation(operation));\n}\n\n/**\n * Trim filename or file URL\n *\n * @param {String} cdnUrl\n * @returns {String}\n */\nexport function trimFilename(cdnUrl) {\n  let url = new URL(cdnUrl);\n  let filename = extractFilename(cdnUrl);\n  let filenamePathPart = isFileUrl(filename) ? splitFileUrl(filename).pathname : filename;\n  url.pathname = url.pathname.replace(filenamePathPart, '');\n  url.search = '';\n  url.hash = '';\n  return url.toString();\n}\n\n/**\n * Detect if filename is actually file URL\n *\n * @param {String} filename\n * @returns {Boolean}\n */\nexport function isFileUrl(filename) {\n  return filename.startsWith('http');\n}\n\n/**\n * Split file URL into the path and search parts\n *\n * @param {String} fileUrl\n * @returns {{ pathname: String; search: String; hash: String }}\n */\nexport function splitFileUrl(fileUrl) {\n  let url = new URL(fileUrl);\n  return {\n    pathname: url.origin + url.pathname || '',\n    search: url.search || '',\n    hash: url.hash || ''\n  };\n}\n\n/**\n * Create a final CDN URL with CDN modifiers and filename\n *\n * @param {String} baseCdnUrl - Base URL to CDN or Proxy, CDN modifiers and filename accepted\n * @param {String} [cdnModifiers] - CDN modifiers to apply, will be appended to `baseCdnUrl` ones\n * @param {String} [filename] - Filename for CDN or file URL for Proxy, will override one from `baseCdnUrl`\n * @returns {String}\n */\nexport const createCdnUrl = (baseCdnUrl, cdnModifiers, filename) => {\n  let url = new URL(trimFilename(baseCdnUrl));\n  filename = filename || extractFilename(baseCdnUrl);\n  // TODO: fix double slash pathname bug (--cfg-cdn-cname: 'https://ucarecdn.com/' - trailing slash case)\n  if (url.pathname.startsWith('//')) {\n    url.pathname = url.pathname.replace('//', '/');\n  }\n  if (isFileUrl(filename)) {\n    let splitted = splitFileUrl(filename);\n    url.pathname = url.pathname + (cdnModifiers || '') + (splitted.pathname || '');\n    url.search = splitted.search;\n    url.hash = splitted.hash;\n  } else {\n    url.pathname = url.pathname + (cdnModifiers || '') + (filename || '');\n  }\n  return url.toString();\n};\n\n/**\n * Create URL for an original file on CDN\n *\n * @param {String} cdnUrl - URL to get base domain from, any pathname will be stripped\n * @param {String} uuid\n * @returns {String}\n */\nexport const createOriginalUrl = (cdnUrl, uuid) => {\n  let url = new URL(cdnUrl);\n  url.pathname = uuid + '/';\n  return url.toString();\n};","map":{"version":3,"names":["normalizeCdnOperation","operation","str","trim","startsWith","slice","endsWith","length","joinCdnOperations","operations","filter","op","map","join","createCdnUrlModifiers","cdnOperations","joined","extractFilename","cdnUrl","url","URL","noOrigin","pathname","search","hash","urlFilenameIdx","lastIndexOf","plainFilenameIdx","filename","extractUuid","slashIndex","indexOf","secondSlashIndex","substring","extractOperations","withoutFilename","trimFilename","operationsMarker","operationsStr","split","Boolean","filenamePathPart","isFileUrl","splitFileUrl","replace","toString","fileUrl","origin","createCdnUrl","baseCdnUrl","cdnModifiers","splitted","createOriginalUrl","uuid"],"sources":["/Users/David/Documents/own_projects/mp4-to-gif/node_modules/@uploadcare/blocks/utils/cdn-utils.js"],"sourcesContent":["/**\n * Trim leading `-/`, `/` and trailing `/` from CDN operation\n *\n * @param {String | unknown} [operation]\n * @returns {String}\n */\nexport const normalizeCdnOperation = (operation) => {\n  if (typeof operation !== 'string' || !operation) {\n    return '';\n  }\n  let str = operation.trim();\n  if (str.startsWith('-/')) {\n    str = str.slice(2);\n  } else if (str.startsWith('/')) {\n    str = str.slice(1);\n  }\n\n  if (str.endsWith('/')) {\n    str = str.slice(0, str.length - 1);\n  }\n  return str;\n};\n\n/**\n * Join multiple CDN operations into one string without trailing or leading delimeters\n *\n * @param {...(String | unknown)} [operations]\n * @returns {String}\n */\nexport const joinCdnOperations = (...operations) => {\n  return operations\n    .filter((op) => typeof op === 'string' && op)\n    .map((op) => normalizeCdnOperation(/** @type {String} */ (op)))\n    .join('/-/');\n};\n\n/**\n * Create string with leading `-/` from passed CDN operations. Do the same as `joinCdnOperations` but adds leading `-/`\n * and trailing `/`\n *\n * @param {...(String | unknown)} [cdnOperations] -\n * @returns {String}\n */\nexport const createCdnUrlModifiers = (...cdnOperations) => {\n  let joined = joinCdnOperations(...cdnOperations);\n  return joined ? `-/${joined}/` : '';\n};\n\n/**\n * Extract filename or file URL\n *\n * @param {String} cdnUrl\n * @returns {String}\n */\nexport function extractFilename(cdnUrl) {\n  let url = new URL(cdnUrl);\n  let noOrigin = url.pathname + url.search + url.hash;\n  let urlFilenameIdx = noOrigin.lastIndexOf('http');\n  let plainFilenameIdx = noOrigin.lastIndexOf('/');\n  let filename = '';\n\n  if (urlFilenameIdx >= 0) {\n    filename = noOrigin.slice(urlFilenameIdx);\n  } else if (plainFilenameIdx >= 0) {\n    filename = noOrigin.slice(plainFilenameIdx + 1);\n  }\n\n  return filename;\n}\n\n/**\n * Extract UUID from CDN URL\n *\n * @param {string} cdnUrl\n * @returns {string}\n */\nexport function extractUuid(cdnUrl) {\n  let url = new URL(cdnUrl);\n  let { pathname } = url;\n  const slashIndex = pathname.indexOf('/');\n  const secondSlashIndex = pathname.indexOf('/', slashIndex + 1);\n  return pathname.substring(slashIndex + 1, secondSlashIndex);\n}\n\n/**\n * Extract UUID from CDN URL\n *\n * @param {string} cdnUrl\n * @returns {string[]}\n */\nexport function extractOperations(cdnUrl) {\n  let withoutFilename = trimFilename(cdnUrl);\n  let url = new URL(withoutFilename);\n  let operationsMarker = url.pathname.indexOf('/-/');\n  if (operationsMarker === -1) {\n    return [];\n  }\n  let operationsStr = url.pathname.substring(operationsMarker);\n\n  return operationsStr\n    .split('/-/')\n    .filter(Boolean)\n    .map((operation) => normalizeCdnOperation(operation));\n}\n\n/**\n * Trim filename or file URL\n *\n * @param {String} cdnUrl\n * @returns {String}\n */\nexport function trimFilename(cdnUrl) {\n  let url = new URL(cdnUrl);\n  let filename = extractFilename(cdnUrl);\n  let filenamePathPart = isFileUrl(filename) ? splitFileUrl(filename).pathname : filename;\n\n  url.pathname = url.pathname.replace(filenamePathPart, '');\n  url.search = '';\n  url.hash = '';\n  return url.toString();\n}\n\n/**\n * Detect if filename is actually file URL\n *\n * @param {String} filename\n * @returns {Boolean}\n */\nexport function isFileUrl(filename) {\n  return filename.startsWith('http');\n}\n\n/**\n * Split file URL into the path and search parts\n *\n * @param {String} fileUrl\n * @returns {{ pathname: String; search: String; hash: String }}\n */\nexport function splitFileUrl(fileUrl) {\n  let url = new URL(fileUrl);\n  return {\n    pathname: url.origin + url.pathname || '',\n    search: url.search || '',\n    hash: url.hash || '',\n  };\n}\n\n/**\n * Create a final CDN URL with CDN modifiers and filename\n *\n * @param {String} baseCdnUrl - Base URL to CDN or Proxy, CDN modifiers and filename accepted\n * @param {String} [cdnModifiers] - CDN modifiers to apply, will be appended to `baseCdnUrl` ones\n * @param {String} [filename] - Filename for CDN or file URL for Proxy, will override one from `baseCdnUrl`\n * @returns {String}\n */\nexport const createCdnUrl = (baseCdnUrl, cdnModifiers, filename) => {\n  let url = new URL(trimFilename(baseCdnUrl));\n  filename = filename || extractFilename(baseCdnUrl);\n  // TODO: fix double slash pathname bug (--cfg-cdn-cname: 'https://ucarecdn.com/' - trailing slash case)\n  if (url.pathname.startsWith('//')) {\n    url.pathname = url.pathname.replace('//', '/');\n  }\n  if (isFileUrl(filename)) {\n    let splitted = splitFileUrl(filename);\n    url.pathname = url.pathname + (cdnModifiers || '') + (splitted.pathname || '');\n    url.search = splitted.search;\n    url.hash = splitted.hash;\n  } else {\n    url.pathname = url.pathname + (cdnModifiers || '') + (filename || '');\n  }\n  return url.toString();\n};\n\n/**\n * Create URL for an original file on CDN\n *\n * @param {String} cdnUrl - URL to get base domain from, any pathname will be stripped\n * @param {String} uuid\n * @returns {String}\n */\nexport const createOriginalUrl = (cdnUrl, uuid) => {\n  let url = new URL(cdnUrl);\n  url.pathname = uuid + '/';\n  return url.toString();\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}